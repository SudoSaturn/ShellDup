// Code generated by go_code.py; DO NOT EDIT.

package notify
import "fmt"
import "github.com/kovidgoyal/kitty/tools/cli"
var _ = fmt.Sprintf
func create_cmd(root *cli.Command, run_func func(*cli.Command, *Options, []string)(int, error)) {
ans := root.AddSubCommand(&cli.Command{
Name: "notify",
ShortDescription: "Send notifications to the user",
Usage: "[options] TITLE [BODY ...]",
HelpText: "Send notifications to the user that are displayed to them via the\ndesktop environment's notifications service. Works over SSH as well.\n\nTo update an existing notification, specify the identifier of the notification\nwith the --identifier option. The value should be the same as the identifier specified for\nthe notification you wish to update.\n\nIf no title is specified and an identifier is specified using the --identifier\noption, then instead of creating a new notification, an existing notification\nwith the specified identifier is closed.\n",
Run: func(cmd *cli.Command, args []string) (int, error) {
opts := Options{}
err := cmd.GetOptionValues(&opts)
if err != nil { return 1, err }
return run_func(cmd, &opts, args)},
})
ans.Add(cli.OptionSpec{
            Name: "--icon -n",
            Type: "list",
            Dest: "Icon",
            Help: "The name of the icon to use for the notification. An icon with this name will be searched for on the computer running the terminal emulator. Can be specified multiple times, the first name that is found will be used. Standard names: error, file-manager, help, info, question, system-monitor, text-editor, warn, warning",
        })
ans.Add(cli.OptionSpec{
            Name: "--icon-path -p",
            Type: "",
            Dest: "IconPath",
            Help: "Path to an image file in PNG/JPEG/GIF formats to use as the icon. If both name and path are specified then first the name will be looked for and if not found then the path will be used.",
        })
ans.Add(cli.OptionSpec{
            Name: "--app-name -a",
            Type: "",
            Dest: "AppName",
            Help: "The application name for the notification.",
        
	Default: "kitten-notify",
})
ans.Add(cli.OptionSpec{
            Name: "--button -b",
            Type: "list",
            Dest: "Button",
            Help: "Add a button with the specified text to the notification. Can be specified multiple times for multiple buttons. If --wait-till-closed is used then the kitten will print the button number to STDOUT if the user clicks a button. 1 for the first button, 2 for the second button and so on.",
        })
ans.Add(cli.OptionSpec{
            Name: "--urgency -u",
            Type: "choices",
            Dest: "Urgency",
            Help: "The urgency of the notification.",
        
Choices: "normal, critical, low",

Completer: cli.NamesCompleter("Choices for urgency", "normal", "critical", "low"),
	Default: "normal",
})
ans.Add(cli.OptionSpec{
            Name: "--expire-after -e",
            Type: "",
            Dest: "ExpireAfter",
            Help: "The duration, for the notification to appear on screen. The default is to use the policy of the OS notification service. A value of :code:`never` means the notification should never expire, however, this may or may not work depending on the policies of the OS notification service. Time is specified in the form NUMBER[SUFFIX] where SUFFIX can be :code:`s` for seconds, :code:`m` for minutes, :code:`h` for hours or :code:`d` for days. Non-integer numbers are allowed. If not specified, seconds is assumed. The notification is guaranteed to be closed automatically after the specified time has elapsed. The notification could be closed before by user action or OS policy.",
        })
ans.Add(cli.OptionSpec{
            Name: "--sound-name -s",
            Type: "",
            Dest: "SoundName",
            Help: "The name of the sound to play with the notification. :code:`system` means let the notification system use whatever sound it wants. :code:`silent` means prevent any sound from being played. Any other value is passed to the desktop's notification system which may or may not honor it.",
        
	Default: "system",
})
ans.Add(cli.OptionSpec{
            Name: "--type -t",
            Type: "",
            Dest: "Type",
            Help: "The notification type. Can be any string, it is used by users to create filter rules for notifications, so choose something descriptive of the notification's purpose.",
        })
ans.Add(cli.OptionSpec{
            Name: "--identifier -i",
            Type: "",
            Dest: "Identifier",
            Help: "The identifier of this notification. If a notification with the same identifier is already displayed, it is replaced/updated.",
        })
ans.Add(cli.OptionSpec{
            Name: "--print-identifier -P",
            Type: "bool-set",
            Dest: "PrintIdentifier",
            Help: "Print the identifier for the notification to STDOUT. Useful when not specifying your own identifier via the --identifier option.",
        })
ans.Add(cli.OptionSpec{
            Name: "--wait-for-completion --wait-till-closed -w",
            Type: "bool-set",
            Dest: "WaitTillClosed",
            Help: "Wait until the notification is closed. If the user activates the notification, \"0\" is printed to STDOUT before quitting. If a button on the notification is pressed the number corresponding to the button is printed to STDOUT. Press the Esc or Ctrl+C keys to close the notification manually.",
        })
ans.Add(cli.OptionSpec{
            Name: "--only-print-escape-code",
            Type: "bool-set",
            Dest: "OnlyPrintEscapeCode",
            Help: "Only print the escape code to STDOUT. Useful if using this kitten as part of a larger application. If this is specified, the --wait-till-closed option will be used for escape code generation, but no actual waiting will be done.",
        })
ans.Add(cli.OptionSpec{
            Name: "--icon-cache-id -g",
            Type: "",
            Dest: "IconCacheId",
            Help: "Identifier to use when caching icons in the terminal emulator. Using an identifier means that icon data needs to be transmitted only once using --icon-path. Subsequent invocations will use the cached icon data, at least until the terminal instance is restarted. This is useful if this kitten is being used inside a larger application, with --only-print-escape-code.",
        })
}
type Options struct {
Icon []string
IconPath string
AppName string
Button []string
Urgency string
ExpireAfter string
SoundName string
Type string
Identifier string
PrintIdentifier bool
WaitTillClosed bool
OnlyPrintEscapeCode bool
IconCacheId string
}
func (opts Options) AsCommandLine() (ans []string) {
	 sval := ""
	 _ = sval
		for _, x := range opts.Icon { ans = append(ans, `--icon=` + x) }
	sval = opts.IconPath
	if (sval != "") { ans = append(ans, `--icon-path=` + sval)}
	sval = opts.AppName
	if (sval != "kitten-notify") { ans = append(ans, `--app-name=` + sval)}
		for _, x := range opts.Button { ans = append(ans, `--button=` + x) }
	sval = opts.Urgency
	if (sval != "normal") { ans = append(ans, `--urgency=` + sval)}
	sval = opts.ExpireAfter
	if (sval != "") { ans = append(ans, `--expire-after=` + sval)}
	sval = opts.SoundName
	if (sval != "system") { ans = append(ans, `--sound-name=` + sval)}
	sval = opts.Type
	if (sval != "") { ans = append(ans, `--type=` + sval)}
	sval = opts.Identifier
	if (sval != "") { ans = append(ans, `--identifier=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.PrintIdentifier)
	if (sval != `false`) { ans = append(ans, `--print-identifier=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.WaitTillClosed)
	if (sval != `false`) { ans = append(ans, `--wait-for-completion=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.OnlyPrintEscapeCode)
	if (sval != `false`) { ans = append(ans, `--only-print-escape-code=` + sval)}
	sval = opts.IconCacheId
	if (sval != "") { ans = append(ans, `--icon-cache-id=` + sval)}
return
}
