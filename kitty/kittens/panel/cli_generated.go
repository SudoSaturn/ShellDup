// Code generated by go_code.py; DO NOT EDIT.

package panel
import "fmt"
import "github.com/kovidgoyal/kitty/tools/cli"
var _ = fmt.Sprintf
func create_cmd(root *cli.Command, run_func func(*cli.Command, *Options, []string)(int, error)) {
ans := root.AddSubCommand(&cli.Command{
Name: "panel",
ShortDescription: "Use a command line program to draw a GPU accelerated panel on your desktop",
Usage: "[options] [cmdline-to-run ...]",
HelpText: "Use a command line program to draw a GPU accelerated panel on your desktop",
Run: func(cmd *cli.Command, args []string) (int, error) {
opts := Options{}
err := cmd.GetOptionValues(&opts)
if err != nil { return 1, err }
return run_func(cmd, &opts, args)},
})
ans.Add(cli.OptionSpec{
            Name: "--lines",
            Type: "",
            Dest: "Lines",
            Help: "The number of lines shown in the panel. Ignored for background, centered, and vertical panels. If it has the suffix :code:`px` then it sets the height of the panel in pixels instead of lines.",
        
	Default: "1",
})
ans.Add(cli.OptionSpec{
            Name: "--columns",
            Type: "",
            Dest: "Columns",
            Help: "The number of columns shown in the panel. Ignored for background, centered, and horizontal panels. If it has the suffix :code:`px` then it sets the width of the panel in pixels instead of columns.",
        
	Default: "1",
})
ans.Add(cli.OptionSpec{
            Name: "--margin-top",
            Type: "int",
            Dest: "MarginTop",
            Help: "Set the top margin for the panel, in pixels. Has no effect for bottom edge panels. Only works on macOS and Wayland compositors that supports the wlr layer shell protocol.",
        
	Default: "0",
})
ans.Add(cli.OptionSpec{
            Name: "--margin-left",
            Type: "int",
            Dest: "MarginLeft",
            Help: "Set the left margin for the panel, in pixels. Has no effect for right edge panels. Only works on macOS and Wayland compositors that supports the wlr layer shell protocol.",
        
	Default: "0",
})
ans.Add(cli.OptionSpec{
            Name: "--margin-bottom",
            Type: "int",
            Dest: "MarginBottom",
            Help: "Set the bottom margin for the panel, in pixels. Has no effect for top edge panels. Only works on macOS and Wayland compositors that supports the wlr layer shell protocol.",
        
	Default: "0",
})
ans.Add(cli.OptionSpec{
            Name: "--margin-right",
            Type: "int",
            Dest: "MarginRight",
            Help: "Set the right margin for the panel, in pixels. Has no effect for left edge panels. Only works on macOS and Wayland compositors that supports the wlr layer shell protocol.",
        
	Default: "0",
})
ans.Add(cli.OptionSpec{
            Name: "--edge",
            Type: "choices",
            Dest: "Edge",
            Help: "Which edge of the screen to place the panel on. Note that some window managers (such as i3) do not support placing docked windows on the left and right edges. The value :code:`background` means make the panel the \"desktop wallpaper\". Note that when using sway if you set a background in your sway config it will cover the background drawn using this kitten. Additionally, there are three more values: :code:`center`, :code:`center-sized` and :code:`none`. The value :code:`center` anchors the panel to all sides and covers the entire display (on macOS the part of the display not covered by titlebar and dock). The panel can be shrunk and placed using the margin parameters. The value :code:`none` anchors the panel to the top left corner and should be placed using the margin parameters. Its size is set by :option:`--lines` and :option:`--columns`. The value :code:`center-sized` is just like :code:`none` except that the panel is centered instead of in the top left corner and the margins have no effect.",
        
Choices: "top, background, bottom, center, center-sized, left, none, right",

Completer: cli.NamesCompleter("Choices for edge", "top", "background", "bottom", "center", "center-sized", "left", "none", "right"),
	Default: "top",
})
ans.Add(cli.OptionSpec{
            Name: "--layer",
            Type: "choices",
            Dest: "Layer",
            Help: "On a Wayland compositor that supports the wlr layer shell protocol, specifies the layer on which the panel should be drawn. This parameter is ignored and set to :code:`background` if :option:`--edge` is set to :code:`background`. On macOS, maps these to appropriate NSWindow *levels*.",
        
Choices: "bottom, background, overlay, top",

Completer: cli.NamesCompleter("Choices for layer", "bottom", "background", "overlay", "top"),
	Default: "bottom",
})
ans.Add(cli.OptionSpec{
            Name: "--config -c",
            Type: "list",
            Dest: "Config",
            Help: "Path to config file to use for kitty when drawing the panel.",
        })
ans.Add(cli.OptionSpec{
            Name: "--override -o",
            Type: "list",
            Dest: "Override",
            Help: "default= Override individual kitty configuration options, can be specified multiple times. Syntax: :italic:`name=value`. For example: :option:`kitty +kitten panel -o` font_size=20",
        })
ans.Add(cli.OptionSpec{
            Name: "--output-name",
            Type: "",
            Dest: "OutputName",
            Help: "The panel can only be displayed on a single monitor (output) at a time. This allows you to specify which output is used, by name. If not specified the compositor will choose an output automatically, typically the last output the user interacted with or the primary monitor. Use the special value :code:`list` to get a list of available outputs. Use :code:`listjson` for a json encoded output. Note that on Wayland the output can only be set at panel creation time, it cannot be changed after creation, nor is there anyway to display a single panel on all outputs. Please complain to the Wayland developers about this.",
        })
ans.Add(cli.OptionSpec{
            Name: "--focus-policy",
            Type: "choices",
            Dest: "FocusPolicy",
            Help: "On a Wayland compositor that supports the wlr layer shell protocol, specify the focus policy for keyboard interactivity with the panel. Please refer to the wlr layer shell protocol documentation for more details. Note that different Wayland compositors behave very differently with :code:`exclusive`, your mileage may vary. On macOS, :code:`exclusive` and :code:`on-demand` are currently the same.",
        
Choices: "not-allowed, exclusive, on-demand",

Completer: cli.NamesCompleter("Choices for focus-policy", "not-allowed", "exclusive", "on-demand"),
	Default: "not-allowed",
})
ans.Add(cli.OptionSpec{
            Name: "--hide-on-focus-loss",
            Type: "bool-set",
            Dest: "HideOnFocusLoss",
            Help: "Automatically hide the panel window when it loses focus. Using this option will force :option:`--focus-policy` to :code:`on-demand`. Note that on Wayland, depending on the compositor, this can result in the window never becoming visible.",
        })
ans.Add(cli.OptionSpec{
            Name: "--grab-keyboard",
            Type: "bool-set",
            Dest: "GrabKeyboard",
            Help: "Grab the keyboard. This means global shortcuts defined in the OS will be passed to kitty instead. Useful if you want to create an OS modal window. How well this works depends on the OS/window manager/desktop environment. On Wayland it works only if the compositor implements the :link:`inhibit-keyboard-shortcuts protocol <https://wayland.app/protocols/keyboard-shortcuts-inhibit-unstable-v1>`. On macOS Apple doesn't allow applications to grab the keyboard without special permissions, so it doesn't work.",
        })
ans.Add(cli.OptionSpec{
            Name: "--exclusive-zone",
            Type: "int",
            Dest: "ExclusiveZone",
            Help: "On a Wayland compositor that supports the wlr layer shell protocol, request a given exclusive zone for the panel. Please refer to the wlr layer shell documentation for more details on the meaning of exclusive and its value. If :option:`--edge` is set to anything other than :code:`center` or :code:`none`, this flag will not have any effect unless the flag :option:`--override-exclusive-zone` is also set. If :option:`--edge` is set to :code:`background`, this option has no effect. Ignored on X11 and macOS.",
        
	Default: "-1",
})
ans.Add(cli.OptionSpec{
            Name: "--override-exclusive-zone",
            Type: "bool-set",
            Dest: "OverrideExclusiveZone",
            Help: "On a Wayland compositor that supports the wlr layer shell protocol, override the default exclusive zone. This has effect only if :option:`--edge` is set to :code:`top`, :code:`left`, :code:`bottom` or :code:`right`. Ignored on X11 and macOS.",
        
	Default: "no",
})
ans.Add(cli.OptionSpec{
            Name: "--single-instance -1",
            Type: "bool-set",
            Dest: "SingleInstance",
            Help: "If specified only a single instance of the panel will run. New invocations will instead create a new top-level window in the existing panel instance.",
        
	Default: "no",
})
ans.Add(cli.OptionSpec{
            Name: "--instance-group",
            Type: "",
            Dest: "InstanceGroup",
            Help: "default= Used in combination with the :option:`--single-instance` option. All panel invocations with the same :option:`--instance-group` will result in new panels being created in the first panel instance within that group.",
        })
ans.Add(cli.OptionSpec{
            Name: "--wait-for-single-instance-window-close",
            Type: "bool-set",
            Dest: "WaitForSingleInstanceWindowClose",
            Help: "Normally, when using :option:`kitty --single-instance`, :italic:`kitty` will open a new window in an existing instance and quit immediately. With this option, it will not quit till the newly opened window is closed. Note that if no previous instance is found, then :italic:`kitty` will wait anyway, regardless of this option.",
        })
ans.Add(cli.OptionSpec{
            Name: "--listen-on",
            Type: "",
            Dest: "ListenOn",
            Help: "Listen on the specified socket address for control messages. For example, :option:`kitty --listen-on`=unix:/tmp/mykitty or :option:`kitty --listen-on`=tcp:localhost:12345. On Linux systems, you can also use abstract UNIX sockets, not associated with a file, like this: :option:`kitty --listen-on`=unix:@mykitty. Environment variables are expanded and relative paths are resolved with respect to the temporary directory. To control kitty, you can send commands to it with :italic:`kitten @` using the :option:`kitten @ --to` option to specify this address. Note that if you run :italic:`kitten @` within a kitty window, there is no need to specify the :option:`kitten @ --to` option as it will automatically read from the environment. Note that this will be ignored unless :opt:`allow_remote_control` is set to either: :code:`yes`, :code:`socket` or :code:`socket-only`. This can also be specified in :file:`kitty.conf`.",
        Completer: complete_kitty_listen_on,})
ans.Add(cli.OptionSpec{
            Name: "--toggle-visibility",
            Type: "bool-set",
            Dest: "ToggleVisibility",
            Help: "When set and using :option:`--single-instance` will toggle the visibility of the existing panel rather than creating a new one.",
        
	Default: "no",
})
ans.Add(cli.OptionSpec{
            Name: "--move-to-active-monitor",
            Type: "bool-set",
            Dest: "MoveToActiveMonitor",
            Help: "When set and using :option:`--toggle-visibility` to show an existing panel, the panel is moved to the active monitor (typically the monitor with the mouse on it). This works only if the underlying OS supports it. It is currently supported on macOS only.",
        
	Default: "false",
})
ans.Add(cli.OptionSpec{
            Name: "--start-as-hidden",
            Type: "bool-set",
            Dest: "StartAsHidden",
            Help: "Start in hidden mode, useful with :option:`--toggle-visibility`.",
        
	Default: "no",
})
ans.Add(cli.OptionSpec{
            Name: "--detach",
            Type: "bool-set",
            Dest: "Detach",
            Help: "Detach from the controlling terminal, if any, running in an independent child process, the parent process exits immediately.",
        
	Default: "no",
})
ans.Add(cli.OptionSpec{
            Name: "--detached-log",
            Type: "",
            Dest: "DetachedLog",
            Help: "default= Path to a log file to store STDOUT/STDERR when using :option:`--detach`",
        })
ans.Add(cli.OptionSpec{
            Name: "--debug-rendering",
            Type: "bool-set",
            Dest: "DebugRendering",
            Help: "For internal debugging use.",
        })
ans.Add(cli.OptionSpec{
            Name: "--debug-input",
            Type: "bool-set",
            Dest: "DebugInput",
            Help: "For internal debugging use.",
        })
}
type Options struct {
Lines string
Columns string
MarginTop int
MarginLeft int
MarginBottom int
MarginRight int
Edge string
Layer string
Config []string
Override []string
OutputName string
FocusPolicy string
HideOnFocusLoss bool
GrabKeyboard bool
ExclusiveZone int
OverrideExclusiveZone bool
SingleInstance bool
InstanceGroup string
WaitForSingleInstanceWindowClose bool
ListenOn string
ToggleVisibility bool
MoveToActiveMonitor bool
StartAsHidden bool
Detach bool
DetachedLog string
DebugRendering bool
DebugInput bool
}
func (opts Options) AsCommandLine() (ans []string) {
	 sval := ""
	 _ = sval
	sval = opts.Lines
	if (sval != "1") { ans = append(ans, `--lines=` + sval)}
	sval = opts.Columns
	if (sval != "1") { ans = append(ans, `--columns=` + sval)}
	sval = fmt.Sprintf(`%d`, opts.MarginTop)
	if (sval != `0`) { ans = append(ans, `--margin-top=` + sval)}
	sval = fmt.Sprintf(`%d`, opts.MarginLeft)
	if (sval != `0`) { ans = append(ans, `--margin-left=` + sval)}
	sval = fmt.Sprintf(`%d`, opts.MarginBottom)
	if (sval != `0`) { ans = append(ans, `--margin-bottom=` + sval)}
	sval = fmt.Sprintf(`%d`, opts.MarginRight)
	if (sval != `0`) { ans = append(ans, `--margin-right=` + sval)}
	sval = opts.Edge
	if (sval != "top") { ans = append(ans, `--edge=` + sval)}
	sval = opts.Layer
	if (sval != "bottom") { ans = append(ans, `--layer=` + sval)}
		for _, x := range opts.Config { ans = append(ans, `--config=` + x) }
		for _, x := range opts.Override { ans = append(ans, `--override=` + x) }
	sval = opts.OutputName
	if (sval != "") { ans = append(ans, `--output-name=` + sval)}
	sval = opts.FocusPolicy
	if (sval != "not-allowed") { ans = append(ans, `--focus-policy=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.HideOnFocusLoss)
	if (sval != `false`) { ans = append(ans, `--hide-on-focus-loss=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.GrabKeyboard)
	if (sval != `false`) { ans = append(ans, `--grab-keyboard=` + sval)}
	sval = fmt.Sprintf(`%d`, opts.ExclusiveZone)
	if (sval != `-1`) { ans = append(ans, `--exclusive-zone=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.OverrideExclusiveZone)
	if (sval != `false`) { ans = append(ans, `--override-exclusive-zone=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.SingleInstance)
	if (sval != `false`) { ans = append(ans, `--single-instance=` + sval)}
	sval = opts.InstanceGroup
	if (sval != "") { ans = append(ans, `--instance-group=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.WaitForSingleInstanceWindowClose)
	if (sval != `false`) { ans = append(ans, `--wait-for-single-instance-window-close=` + sval)}
	sval = opts.ListenOn
	if (sval != "") { ans = append(ans, `--listen-on=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.ToggleVisibility)
	if (sval != `false`) { ans = append(ans, `--toggle-visibility=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.MoveToActiveMonitor)
	if (sval != `false`) { ans = append(ans, `--move-to-active-monitor=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.StartAsHidden)
	if (sval != `false`) { ans = append(ans, `--start-as-hidden=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.Detach)
	if (sval != `false`) { ans = append(ans, `--detach=` + sval)}
	sval = opts.DetachedLog
	if (sval != "") { ans = append(ans, `--detached-log=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.DebugRendering)
	if (sval != `false`) { ans = append(ans, `--debug-rendering=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.DebugInput)
	if (sval != `false`) { ans = append(ans, `--debug-input=` + sval)}
return
}
