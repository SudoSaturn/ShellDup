// Code generated by go_code.py; DO NOT EDIT.

package choose_files
import "fmt"
import "strconv"
import "github.com/kovidgoyal/kitty/tools/config"
import "github.com/kovidgoyal/kitty/tools/utils/style"
var _ = fmt.Println
var _ = config.StringToBool
var _ = strconv.Atoi
var _ = style.ParseColor
type Respect_ignores_Choice_Type int
type Show_hidden_Choice_Type int
type Show_preview_Choice_Type int
type Sort_by_last_modified_Choice_Type int
type Config struct {
Cache_size float64
Dark_pygments_style string
Ignore []string
Pygments_style string
Respect_ignores Respect_ignores_Choice_Type
Show_hidden Show_hidden_Choice_Type
Show_preview Show_preview_Choice_Type
Sort_by_last_modified Sort_by_last_modified_Choice_Type
Syntax_aliases map[string]string
KeyboardShortcuts []*config.KeyAction
}
func NewConfig() *Config {
return &Config{
Cache_size: 0.5,
Dark_pygments_style: `github-dark`,
Pygments_style: `default`,
Respect_ignores: Respect_ignores_last,
Show_hidden: Show_hidden_last,
Show_preview: Show_preview_last,
Sort_by_last_modified: Sort_by_last_modified_last,
Syntax_aliases: map[string]string{"pyj": "py","pyi": "py","recipe": "py",},
KeyboardShortcuts: []*config.KeyAction{
{Name: "quit", Args: "", Normalized_keys: []string{
"esc",
}},
{Name: "quit", Args: "", Normalized_keys: []string{
"ctrl+c",
}},
{Name: "accept", Args: "", Normalized_keys: []string{
"enter",
}},
{Name: "select", Args: "", Normalized_keys: []string{
"shift+enter",
}},
{Name: "typename", Args: "", Normalized_keys: []string{
"ctrl+enter",
}},
{Name: "next", Args: "1", Normalized_keys: []string{
"down",
}},
{Name: "next", Args: "-1", Normalized_keys: []string{
"up",
}},
{Name: "next", Args: "left", Normalized_keys: []string{
"left",
}},
{Name: "next", Args: "right", Normalized_keys: []string{
"right",
}},
{Name: "next", Args: "first_on_screen", Normalized_keys: []string{
"home",
}},
{Name: "next", Args: "last_on_screen", Normalized_keys: []string{
"end",
}},
{Name: "next", Args: "first", Normalized_keys: []string{
"ctrl+home",
}},
{Name: "next", Args: "last", Normalized_keys: []string{
"ctrl+end",
}},
{Name: "cd", Args: ".", Normalized_keys: []string{
"tab",
}},
{Name: "cd", Args: "..", Normalized_keys: []string{
"shift+tab",
}},
{Name: "cd", Args: "/", Normalized_keys: []string{
"ctrl+/",
}},
{Name: "cd", Args: "~", Normalized_keys: []string{
"ctrl+~",
}},
{Name: "cd", Args: "~", Normalized_keys: []string{
"ctrl+`",
}},
{Name: "cd", Args: "~", Normalized_keys: []string{
"ctrl+shift+`",
}},
{Name: "cd", Args: "/tmp", Normalized_keys: []string{
"ctrl+t",
}},
{Name: "1", Args: "", Normalized_keys: []string{
"ctrl+f",
}},
{Name: "-1", Args: "", Normalized_keys: []string{
"alt+f",
}},
{Name: "toggle", Args: "dotfiles", Normalized_keys: []string{
"alt+h",
}},
{Name: "toggle", Args: "ignorefiles", Normalized_keys: []string{
"alt+i",
}},
{Name: "toggle", Args: "sort_by_dates", Normalized_keys: []string{
"alt+d",
}},
{Name: "toggle", Args: "preview", Normalized_keys: []string{
"alt+p",
}},
},
}}
const (
Respect_ignores_last Respect_ignores_Choice_Type = iota
Respect_ignores_yes
Respect_ignores_y
Respect_ignores_true
Respect_ignores_no
Respect_ignores_n
Respect_ignores_false
)
func (x Respect_ignores_Choice_Type) String() string {
switch x {
default: return ""
case Respect_ignores_last: return "last"
case Respect_ignores_yes: return "yes"
case Respect_ignores_y: return "y"
case Respect_ignores_true: return "true"
case Respect_ignores_no: return "no"
case Respect_ignores_n: return "n"
case Respect_ignores_false: return "false"
}}
func Parse_Respect_ignores(val string) (ans Respect_ignores_Choice_Type, err error) {
switch val {
case "last": return Respect_ignores_last, nil
case "yes": return Respect_ignores_yes, nil
case "y": return Respect_ignores_y, nil
case "true": return Respect_ignores_true, nil
case "no": return Respect_ignores_no, nil
case "n": return Respect_ignores_n, nil
case "false": return Respect_ignores_false, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "false", "last, yes, y, true, no, n, false")
}}
const (
Show_hidden_last Show_hidden_Choice_Type = iota
Show_hidden_yes
Show_hidden_y
Show_hidden_true
Show_hidden_no
Show_hidden_n
Show_hidden_false
)
func (x Show_hidden_Choice_Type) String() string {
switch x {
default: return ""
case Show_hidden_last: return "last"
case Show_hidden_yes: return "yes"
case Show_hidden_y: return "y"
case Show_hidden_true: return "true"
case Show_hidden_no: return "no"
case Show_hidden_n: return "n"
case Show_hidden_false: return "false"
}}
func Parse_Show_hidden(val string) (ans Show_hidden_Choice_Type, err error) {
switch val {
case "last": return Show_hidden_last, nil
case "yes": return Show_hidden_yes, nil
case "y": return Show_hidden_y, nil
case "true": return Show_hidden_true, nil
case "no": return Show_hidden_no, nil
case "n": return Show_hidden_n, nil
case "false": return Show_hidden_false, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "false", "last, yes, y, true, no, n, false")
}}
const (
Show_preview_last Show_preview_Choice_Type = iota
Show_preview_yes
Show_preview_y
Show_preview_true
Show_preview_no
Show_preview_n
Show_preview_false
)
func (x Show_preview_Choice_Type) String() string {
switch x {
default: return ""
case Show_preview_last: return "last"
case Show_preview_yes: return "yes"
case Show_preview_y: return "y"
case Show_preview_true: return "true"
case Show_preview_no: return "no"
case Show_preview_n: return "n"
case Show_preview_false: return "false"
}}
func Parse_Show_preview(val string) (ans Show_preview_Choice_Type, err error) {
switch val {
case "last": return Show_preview_last, nil
case "yes": return Show_preview_yes, nil
case "y": return Show_preview_y, nil
case "true": return Show_preview_true, nil
case "no": return Show_preview_no, nil
case "n": return Show_preview_n, nil
case "false": return Show_preview_false, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "false", "last, yes, y, true, no, n, false")
}}
const (
Sort_by_last_modified_last Sort_by_last_modified_Choice_Type = iota
Sort_by_last_modified_yes
Sort_by_last_modified_y
Sort_by_last_modified_true
Sort_by_last_modified_no
Sort_by_last_modified_n
Sort_by_last_modified_false
)
func (x Sort_by_last_modified_Choice_Type) String() string {
switch x {
default: return ""
case Sort_by_last_modified_last: return "last"
case Sort_by_last_modified_yes: return "yes"
case Sort_by_last_modified_y: return "y"
case Sort_by_last_modified_true: return "true"
case Sort_by_last_modified_no: return "no"
case Sort_by_last_modified_n: return "n"
case Sort_by_last_modified_false: return "false"
}}
func Parse_Sort_by_last_modified(val string) (ans Sort_by_last_modified_Choice_Type, err error) {
switch val {
case "last": return Sort_by_last_modified_last, nil
case "yes": return Sort_by_last_modified_yes, nil
case "y": return Sort_by_last_modified_y, nil
case "true": return Sort_by_last_modified_true, nil
case "no": return Sort_by_last_modified_no, nil
case "n": return Sort_by_last_modified_n, nil
case "false": return Sort_by_last_modified_false, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "false", "last, yes, y, true, no, n, false")
}}
func (c *Config) Parse(key, val string) (err error) {
switch key {
default: return fmt.Errorf("Unknown configuration key: %#v", key)
case "cache_size":
var temp_val float64
temp_val, err = config.PositiveFloat(val)
if err != nil { return fmt.Errorf("Failed to parse cache_size = %#v with error: %w", val, err) }
c.Cache_size = temp_val
case "dark_pygments_style":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse dark_pygments_style = %#v with error: %w", val, err) }
c.Dark_pygments_style = temp_val
case "ignore":
var temp_val []string
temp_val, err = []string{val}, nil
if err != nil { return fmt.Errorf("Failed to parse ignore = %#v with error: %w", val, err) }
c.Ignore = append(c.Ignore, temp_val...)
case "pygments_style":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse pygments_style = %#v with error: %w", val, err) }
c.Pygments_style = temp_val
case "respect_ignores":
var temp_val Respect_ignores_Choice_Type
temp_val, err = Parse_Respect_ignores(val)
if err != nil { return fmt.Errorf("Failed to parse respect_ignores = %#v with error: %w", val, err) }
c.Respect_ignores = temp_val
case "show_hidden":
var temp_val Show_hidden_Choice_Type
temp_val, err = Parse_Show_hidden(val)
if err != nil { return fmt.Errorf("Failed to parse show_hidden = %#v with error: %w", val, err) }
c.Show_hidden = temp_val
case "show_preview":
var temp_val Show_preview_Choice_Type
temp_val, err = Parse_Show_preview(val)
if err != nil { return fmt.Errorf("Failed to parse show_preview = %#v with error: %w", val, err) }
c.Show_preview = temp_val
case "sort_by_last_modified":
var temp_val Sort_by_last_modified_Choice_Type
temp_val, err = Parse_Sort_by_last_modified(val)
if err != nil { return fmt.Errorf("Failed to parse sort_by_last_modified = %#v with error: %w", val, err) }
c.Sort_by_last_modified = temp_val
case "syntax_aliases":
var temp_val map[string]string
temp_val, err = config.ParseStrDict(val, ` `, `:`)
if err != nil { return fmt.Errorf("Failed to parse syntax_aliases = %#v with error: %w", val, err) }
c.Syntax_aliases = temp_val
case "map":
tempsc, err := config.ParseMap(val)
if err != nil { return fmt.Errorf("Failed to parse map = %#v with error: %w", val, err) }
c.KeyboardShortcuts = append(c.KeyboardShortcuts, tempsc)
}
return}
