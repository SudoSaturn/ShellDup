// Code generated by go_code.py; DO NOT EDIT.

package quick_access_terminal
import "fmt"
import "strconv"
import "github.com/kovidgoyal/kitty/tools/config"
import "github.com/kovidgoyal/kitty/tools/utils/style"
var _ = fmt.Println
var _ = config.StringToBool
var _ = strconv.Atoi
var _ = style.ParseColor
type Edge_Choice_Type int
type Focus_policy_Choice_Type int
type Config struct {
App_id string
Background_opacity float64
Columns string
Edge Edge_Choice_Type
Focus_policy Focus_policy_Choice_Type
Grab_keyboard bool
Hide_on_focus_loss bool
Kitty_conf []string
Kitty_override []string
Lines string
Margin_bottom int64
Margin_left int64
Margin_right int64
Margin_top int64
Output_name string
Start_as_hidden bool
}
func NewConfig() *Config {
return &Config{
App_id: `kitty-quick-access`,
Background_opacity: 0.85,
Columns: `80`,
Edge: Edge_top,
Focus_policy: Focus_policy_exclusive,
Lines: `25`,
}}
const (
Edge_top Edge_Choice_Type = iota
Edge_bottom
Edge_left
Edge_right
Edge_background
Edge_center
Edge_center_sized
Edge_none
)
func (x Edge_Choice_Type) String() string {
switch x {
default: return ""
case Edge_top: return "top"
case Edge_bottom: return "bottom"
case Edge_left: return "left"
case Edge_right: return "right"
case Edge_background: return "background"
case Edge_center: return "center"
case Edge_center_sized: return "center-sized"
case Edge_none: return "none"
}}
func Parse_Edge(val string) (ans Edge_Choice_Type, err error) {
switch val {
case "top": return Edge_top, nil
case "bottom": return Edge_bottom, nil
case "left": return Edge_left, nil
case "right": return Edge_right, nil
case "background": return Edge_background, nil
case "center": return Edge_center, nil
case "center-sized": return Edge_center_sized, nil
case "none": return Edge_none, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "none", "top, bottom, left, right, background, center, center-sized, none")
}}
const (
Focus_policy_not_allowed Focus_policy_Choice_Type = iota
Focus_policy_exclusive
Focus_policy_on_demand
)
func (x Focus_policy_Choice_Type) String() string {
switch x {
default: return ""
case Focus_policy_not_allowed: return "not-allowed"
case Focus_policy_exclusive: return "exclusive"
case Focus_policy_on_demand: return "on-demand"
}}
func Parse_Focus_policy(val string) (ans Focus_policy_Choice_Type, err error) {
switch val {
case "not-allowed": return Focus_policy_not_allowed, nil
case "exclusive": return Focus_policy_exclusive, nil
case "on-demand": return Focus_policy_on_demand, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "on-demand", "not-allowed, exclusive, on-demand")
}}
func (c *Config) Parse(key, val string) (err error) {
switch key {
default: return fmt.Errorf("Unknown configuration key: %#v", key)
case "app_id":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse app_id = %#v with error: %w", val, err) }
c.App_id = temp_val
case "background_opacity":
var temp_val float64
temp_val, err = config.UnitFloat(val)
if err != nil { return fmt.Errorf("Failed to parse background_opacity = %#v with error: %w", val, err) }
c.Background_opacity = temp_val
case "columns":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse columns = %#v with error: %w", val, err) }
c.Columns = temp_val
case "edge":
var temp_val Edge_Choice_Type
temp_val, err = Parse_Edge(val)
if err != nil { return fmt.Errorf("Failed to parse edge = %#v with error: %w", val, err) }
c.Edge = temp_val
case "focus_policy":
var temp_val Focus_policy_Choice_Type
temp_val, err = Parse_Focus_policy(val)
if err != nil { return fmt.Errorf("Failed to parse focus_policy = %#v with error: %w", val, err) }
c.Focus_policy = temp_val
case "grab_keyboard":
var temp_val bool
temp_val, err = config.StringToBool(val), nil
if err != nil { return fmt.Errorf("Failed to parse grab_keyboard = %#v with error: %w", val, err) }
c.Grab_keyboard = temp_val
case "hide_on_focus_loss":
var temp_val bool
temp_val, err = config.StringToBool(val), nil
if err != nil { return fmt.Errorf("Failed to parse hide_on_focus_loss = %#v with error: %w", val, err) }
c.Hide_on_focus_loss = temp_val
case "kitty_conf":
var temp_val []string
temp_val, err = []string{val}, nil
if err != nil { return fmt.Errorf("Failed to parse kitty_conf = %#v with error: %w", val, err) }
c.Kitty_conf = append(c.Kitty_conf, temp_val...)
case "kitty_override":
var temp_val []string
temp_val, err = []string{val}, nil
if err != nil { return fmt.Errorf("Failed to parse kitty_override = %#v with error: %w", val, err) }
c.Kitty_override = append(c.Kitty_override, temp_val...)
case "lines":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse lines = %#v with error: %w", val, err) }
c.Lines = temp_val
case "margin_bottom":
var temp_val int64
temp_val, err = strconv.ParseInt(val, 10, 64)
if err != nil { return fmt.Errorf("Failed to parse margin_bottom = %#v with error: %w", val, err) }
c.Margin_bottom = temp_val
case "margin_left":
var temp_val int64
temp_val, err = strconv.ParseInt(val, 10, 64)
if err != nil { return fmt.Errorf("Failed to parse margin_left = %#v with error: %w", val, err) }
c.Margin_left = temp_val
case "margin_right":
var temp_val int64
temp_val, err = strconv.ParseInt(val, 10, 64)
if err != nil { return fmt.Errorf("Failed to parse margin_right = %#v with error: %w", val, err) }
c.Margin_right = temp_val
case "margin_top":
var temp_val int64
temp_val, err = strconv.ParseInt(val, 10, 64)
if err != nil { return fmt.Errorf("Failed to parse margin_top = %#v with error: %w", val, err) }
c.Margin_top = temp_val
case "output_name":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse output_name = %#v with error: %w", val, err) }
c.Output_name = temp_val
case "start_as_hidden":
var temp_val bool
temp_val, err = config.StringToBool(val), nil
if err != nil { return fmt.Errorf("Failed to parse start_as_hidden = %#v with error: %w", val, err) }
c.Start_as_hidden = temp_val
}
return}
