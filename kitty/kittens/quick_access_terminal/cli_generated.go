// Code generated by go_code.py; DO NOT EDIT.

package quick_access_terminal
import "fmt"
import "github.com/kovidgoyal/kitty/tools/cli"
var _ = fmt.Sprintf
func create_cmd(root *cli.Command, run_func func(*cli.Command, *Options, []string)(int, error)) {
ans := root.AddSubCommand(&cli.Command{
Name: "quick_access_terminal",
ShortDescription: "A quick access terminal window that you can bring up instantly with a keypress or a command.",
Usage: "[options] [cmdline-to-run ...]",
HelpText: "A quick access terminal window that you can bring up instantly with a keypress or a command.",
Run: func(cmd *cli.Command, args []string) (int, error) {
opts := Options{}
err := cmd.GetOptionValues(&opts)
if err != nil { return 1, err }
return run_func(cmd, &opts, args)},
Hidden: true,
})
ans.Add(cli.OptionSpec{
            Name: "--config -c",
            Type: "list",
            Dest: "Config",
            Help: "Specify a path to the configuration file(s) to use. All configuration files are merged onto the builtin :file:`quick-access-terminal.conf`, overriding the builtin values. This option can be specified multiple times to read multiple configuration files in sequence, which are merged. Use the special value :code:`NONE` to not load any config file.\n\nIf this option is not specified, config files are searched for in the order: :file:`$XDG_CONFIG_HOME/kitty/quick-access-terminal.conf`, :file:`~/.config/kitty/quick-access-terminal.conf`, :file:`~/Library/Preferences/kitty/quick-access-terminal.conf`, :file:`$XDG_CONFIG_DIRS/kitty/quick-access-terminal.conf`. The first one that exists is used as the config file.\n\nIf the environment variable :envvar:`KITTY_CONFIG_DIRECTORY` is specified, that directory is always used and the above searching does not happen.\n\nIf :file:`/etc/xdg/kitty/quick-access-terminal.conf` exists, it is merged before (i.e. with lower priority) than any user config files. It can be used to specify system-wide defaults for all users. You can use either :code:`-` or :file:`/dev/stdin` to read the config from STDIN.",
        Completer: cli.ChainCompleters(cli.NamesCompleter("Keywords", "none", "NONE"), cli.FnmatchCompleter("Config files", cli.CWD, "*.conf")),})
ans.Add(cli.OptionSpec{
            Name: "--override -o",
            Type: "list",
            Dest: "Override",
            Help: "Override individual configuration options, can be specified multiple times. Syntax: :italic:`name=value`. For example: :italic:`-o lines=12`",
        })
ans.Add(cli.OptionSpec{
            Name: "--detach",
            Type: "bool-set",
            Dest: "Detach",
            Help: "Detach from the controlling terminal, if any, running in an independent child process, the parent process exits immediately.",
        })
ans.Add(cli.OptionSpec{
            Name: "--detached-log",
            Type: "",
            Dest: "DetachedLog",
            Help: "Path to a log file to store STDOUT/STDERR when using :option:`--detach`",
        })
ans.Add(cli.OptionSpec{
            Name: "--instance-group",
            Type: "",
            Dest: "InstanceGroup",
            Help: "The unique name of this quick access terminal Use a different name if you want multiple such terminals.",
        
	Default: "quick-access",
})
ans.Add(cli.OptionSpec{
            Name: "--debug-rendering",
            Type: "bool-set",
            Dest: "DebugRendering",
            Help: "For debugging interactions with the compositor/window manager.",
        })
ans.Add(cli.OptionSpec{
            Name: "--debug-input",
            Type: "bool-set",
            Dest: "DebugInput",
            Help: "For debugging interactions with the compositor/window manager.",
        })
clone := root.AddClone(ans.Group, ans)
clone.Hidden = false
clone.Name = "quick-access-terminal"
}
type Options struct {
Config []string
Override []string
Detach bool
DetachedLog string
InstanceGroup string
DebugRendering bool
DebugInput bool
}
func (opts Options) AsCommandLine() (ans []string) {
	 sval := ""
	 _ = sval
		for _, x := range opts.Config { ans = append(ans, `--config=` + x) }
		for _, x := range opts.Override { ans = append(ans, `--override=` + x) }
	sval = fmt.Sprintf(`%#v`, opts.Detach)
	if (sval != `false`) { ans = append(ans, `--detach=` + sval)}
	sval = opts.DetachedLog
	if (sval != "") { ans = append(ans, `--detached-log=` + sval)}
	sval = opts.InstanceGroup
	if (sval != "quick-access") { ans = append(ans, `--instance-group=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.DebugRendering)
	if (sval != `false`) { ans = append(ans, `--debug-rendering=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.DebugInput)
	if (sval != `false`) { ans = append(ans, `--debug-input=` + sval)}
return
}
