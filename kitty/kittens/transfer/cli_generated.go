// Code generated by go_code.py; DO NOT EDIT.

package transfer
import "fmt"
import "github.com/kovidgoyal/kitty/tools/cli"
var _ = fmt.Sprintf
func create_cmd(root *cli.Command, run_func func(*cli.Command, *Options, []string)(int, error)) {
ans := root.AddSubCommand(&cli.Command{
Name: "transfer",
ShortDescription: "Transfer files easily over the TTY device",
Usage: "[options] source_files_or_directories destination_path",
HelpText: "Transfer files over the TTY device. Can be used to send files between any two\ncomputers provided there is a TTY connection between them, such as over SSH.\nSupports copying files, directories (recursively), symlinks and hardlinks.  Can\neven use an rsync like protocol to copy only changes between files.  When\ncopying multiple files, use the --confirm-paths option to see what exactly will\nbe copied. The easiest way to use this kitten is to first ssh into the remote\ncomputer with the ssh kitten:\n\n.. code::\n\n    $ kitten ssh my-remote-computer\n\nThen, on the remote computer run the transfer kitten to do your copying.\nTo copy a file from the remote computer to the local computer, run:\n\n.. code::\n\n    $ kitten transfer remote-file /path/to/local-file\n\nThis will copy :file:`remote-file` from the remote computer to :file:`/path/to/local-file`\non the local computer.\n\nSimilarly, to copy a file from the local computer to the remote one, run:\n\n.. code::\n\n    $ kitten transfer --direction=upload /path/to/local-file remote-file\n\nThis will copy :file:`/path/to/local-file` from the local computer\nto :file:`remote-file` on the remote computer.\n\nMultiple files can be copied:\n\n.. code::\n\n    $ kitten transfer file1 file2 /path/to/dir/\n\nThis will put :code:`file1` and :code:`file2` into the directory\n:file:`/path/to/dir/` on the local computer.\n\nDirectories can also be copied, recursively:\n\n.. code::\n\n    $ kitten transfer dir1 /path/to/dir/\n\nThis will put :file:`dir1` and all its contents into\n:file:`/path/to/dir/` on the local computer.\n\nNote that when copying multiple files or directories, the destination\nmust be an existing directory on the receiving computer. Relative file\npaths are resolved with respect to the current directory on the computer\nrunning the kitten and the home directory on the other computer. It is\na good idea to use the :option:`--confirm-paths` command line flag to verify\nthe kitten will copy the files you expect it to.\n",
Run: func(cmd *cli.Command, args []string) (int, error) {
opts := Options{}
err := cmd.GetOptionValues(&opts)
if err != nil { return 1, err }
return run_func(cmd, &opts, args)},
})
ans.Add(cli.OptionSpec{
            Name: "--direction -d",
            Type: "choices",
            Dest: "Direction",
            Help: "Whether to send or receive files. :code:`send` or :code:`download` copy files from the computer on which the kitten is running (usually the remote computer) to the local computer. :code:`receive` or :code:`upload` copy files from the local computer to the remote computer.",
        
Choices: "download, receive, send, upload",

Completer: cli.NamesCompleter("Choices for direction", "download", "receive", "send", "upload"),
	Default: "download",
})
ans.Add(cli.OptionSpec{
            Name: "--mode -m",
            Type: "choices",
            Dest: "Mode",
            Help: "How to interpret command line arguments. In :code:`mirror` mode all arguments are assumed to be files/dirs on the sending computer and they are mirrored onto the receiving computer. Files under the HOME directory are copied to the HOME directory on the receiving computer even if the HOME directory is different. In :code:`normal` mode the last argument is assumed to be a destination path on the receiving computer. The last argument must be an existing directory unless copying a single file. When it is a directory it should end with a trailing slash.",
        
Choices: "normal, mirror",

Completer: cli.NamesCompleter("Choices for mode", "normal", "mirror"),
	Default: "normal",
})
ans.Add(cli.OptionSpec{
            Name: "--compress",
            Type: "choices",
            Dest: "Compress",
            Help: "Whether to compress data being sent. By default compression is enabled based on the type of file being sent. For files recognized as being already compressed, compression is turned off as it just wastes CPU cycles.",
        
Choices: "auto, always, never",

Completer: cli.NamesCompleter("Choices for compress", "auto", "always", "never"),
	Default: "auto",
})
ans.Add(cli.OptionSpec{
            Name: "--permissions-bypass -p",
            Type: "",
            Dest: "PermissionsBypass",
            Help: "The password to use to skip the transfer confirmation popup in kitty. Must match the password set for the :opt:`file_transfer_confirmation_bypass` option in :file:`kitty.conf`. Note that leading and trailing whitespace is removed from the password. A password starting with :code:`.`, :code:`/` or :code:`~` characters is assumed to be a file name to read the password from. A value of :code:`-` means read the password from STDIN. A password that is purely a number less than 256 is assumed to be the number of a file descriptor from which to read the actual password.",
        })
ans.Add(cli.OptionSpec{
            Name: "--confirm-paths -c",
            Type: "bool-set",
            Dest: "ConfirmPaths",
            Help: "Before actually transferring files, show a mapping of local file names to remote file names and ask for confirmation.",
        })
ans.Add(cli.OptionSpec{
            Name: "--transmit-deltas -x",
            Type: "bool-set",
            Dest: "TransmitDeltas",
            Help: "If a file on the receiving side already exists, use the rsync algorithm to update it to match the file on the sending side, potentially saving lots of bandwidth and also automatically resuming partial transfers. Note that this will actually degrade performance on fast links or with small files, so use with care.",
        })
ans.ArgCompleter = cli.FnmatchCompleter("Files", cli.CWD, "*")
}
type Options struct {
Direction string
Mode string
Compress string
PermissionsBypass string
ConfirmPaths bool
TransmitDeltas bool
}
func (opts Options) AsCommandLine() (ans []string) {
	 sval := ""
	 _ = sval
	sval = opts.Direction
	if (sval != "download") { ans = append(ans, `--direction=` + sval)}
	sval = opts.Mode
	if (sval != "normal") { ans = append(ans, `--mode=` + sval)}
	sval = opts.Compress
	if (sval != "auto") { ans = append(ans, `--compress=` + sval)}
	sval = opts.PermissionsBypass
	if (sval != "") { ans = append(ans, `--permissions-bypass=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.ConfirmPaths)
	if (sval != `false`) { ans = append(ans, `--confirm-paths=` + sval)}
	sval = fmt.Sprintf(`%#v`, opts.TransmitDeltas)
	if (sval != `false`) { ans = append(ans, `--transmit-deltas=` + sval)}
return
}
