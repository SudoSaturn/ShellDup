// Code generated by go_code.py; DO NOT EDIT.

package ssh
import "fmt"
import "strconv"
import "github.com/kovidgoyal/kitty/tools/config"
import "github.com/kovidgoyal/kitty/tools/utils/style"
var _ = fmt.Println
var _ = config.StringToBool
var _ = strconv.Atoi
var _ = style.ParseColor
type Askpass_Choice_Type int
type Remote_kitty_Choice_Type int
type Config struct {
Askpass Askpass_Choice_Type
Color_scheme string
Copy []*CopyInstruction
Cwd string
Delegate string
Env []*EnvInstruction
Forward_remote_control bool
Hostname string
Interpreter string
Login_shell string
Password string
Remote_dir string
Remote_kitty Remote_kitty_Choice_Type
Share_connections bool
Shell_integration string
Totp_digits int64
Totp_period int64
Totp_secret string
}
func NewConfig() *Config {
return &Config{
Askpass: Askpass_unless_set,
Hostname: `*`,
Interpreter: `sh`,
Remote_dir: `.local/share/kitty-ssh-kitten`,
Remote_kitty: Remote_kitty_if_needed,
Share_connections: true,
Shell_integration: `inherited`,
Totp_digits: 6,
Totp_period: 30,
}}
const (
Askpass_unless_set Askpass_Choice_Type = iota
Askpass_ssh
Askpass_native
)
func (x Askpass_Choice_Type) String() string {
switch x {
default: return ""
case Askpass_unless_set: return "unless-set"
case Askpass_ssh: return "ssh"
case Askpass_native: return "native"
}}
func Parse_Askpass(val string) (ans Askpass_Choice_Type, err error) {
switch val {
case "unless-set": return Askpass_unless_set, nil
case "ssh": return Askpass_ssh, nil
case "native": return Askpass_native, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "native", "unless-set, ssh, native")
}}
const (
Remote_kitty_if_needed Remote_kitty_Choice_Type = iota
Remote_kitty_no
Remote_kitty_yes
)
func (x Remote_kitty_Choice_Type) String() string {
switch x {
default: return ""
case Remote_kitty_if_needed: return "if-needed"
case Remote_kitty_no: return "no"
case Remote_kitty_yes: return "yes"
}}
func Parse_Remote_kitty(val string) (ans Remote_kitty_Choice_Type, err error) {
switch val {
case "if-needed": return Remote_kitty_if_needed, nil
case "no": return Remote_kitty_no, nil
case "yes": return Remote_kitty_yes, nil
default: return ans, fmt.Errorf("%#v is not a valid value for %s. Valid values are: %s", val, "yes", "if-needed, no, yes")
}}
func (c *Config) Parse(key, val string) (err error) {
switch key {
default: return fmt.Errorf("Unknown configuration key: %#v", key)
case "askpass":
var temp_val Askpass_Choice_Type
temp_val, err = Parse_Askpass(val)
if err != nil { return fmt.Errorf("Failed to parse askpass = %#v with error: %w", val, err) }
c.Askpass = temp_val
case "color_scheme":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse color_scheme = %#v with error: %w", val, err) }
c.Color_scheme = temp_val
case "copy":
var temp_val []*CopyInstruction
temp_val, err = ParseCopyInstruction(val)
if err != nil { return fmt.Errorf("Failed to parse copy = %#v with error: %w", val, err) }
c.Copy = append(c.Copy, temp_val...)
case "cwd":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse cwd = %#v with error: %w", val, err) }
c.Cwd = temp_val
case "delegate":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse delegate = %#v with error: %w", val, err) }
c.Delegate = temp_val
case "env":
var temp_val []*EnvInstruction
temp_val, err = ParseEnvInstruction(val)
if err != nil { return fmt.Errorf("Failed to parse env = %#v with error: %w", val, err) }
c.Env = append(c.Env, temp_val...)
case "forward_remote_control":
var temp_val bool
temp_val, err = config.StringToBool(val), nil
if err != nil { return fmt.Errorf("Failed to parse forward_remote_control = %#v with error: %w", val, err) }
c.Forward_remote_control = temp_val
case "hostname":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse hostname = %#v with error: %w", val, err) }
c.Hostname = temp_val
case "interpreter":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse interpreter = %#v with error: %w", val, err) }
c.Interpreter = temp_val
case "login_shell":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse login_shell = %#v with error: %w", val, err) }
c.Login_shell = temp_val
case "password":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse password = %#v with error: %w", val, err) }
c.Password = temp_val
case "remote_dir":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse remote_dir = %#v with error: %w", val, err) }
c.Remote_dir = temp_val
case "remote_kitty":
var temp_val Remote_kitty_Choice_Type
temp_val, err = Parse_Remote_kitty(val)
if err != nil { return fmt.Errorf("Failed to parse remote_kitty = %#v with error: %w", val, err) }
c.Remote_kitty = temp_val
case "share_connections":
var temp_val bool
temp_val, err = config.StringToBool(val), nil
if err != nil { return fmt.Errorf("Failed to parse share_connections = %#v with error: %w", val, err) }
c.Share_connections = temp_val
case "shell_integration":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse shell_integration = %#v with error: %w", val, err) }
c.Shell_integration = temp_val
case "totp_digits":
var temp_val int64
temp_val, err = strconv.ParseInt(val, 10, 64)
if err != nil { return fmt.Errorf("Failed to parse totp_digits = %#v with error: %w", val, err) }
c.Totp_digits = temp_val
case "totp_period":
var temp_val int64
temp_val, err = strconv.ParseInt(val, 10, 64)
if err != nil { return fmt.Errorf("Failed to parse totp_period = %#v with error: %w", val, err) }
c.Totp_period = temp_val
case "totp_secret":
var temp_val string
temp_val, err = val, nil
if err != nil { return fmt.Errorf("Failed to parse totp_secret = %#v with error: %w", val, err) }
c.Totp_secret = temp_val
}
return}
