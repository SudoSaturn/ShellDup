// Code generated by go_code.py; DO NOT EDIT.

package ssh
import "github.com/kovidgoyal/kitty/tools/cli"
type copy_options struct {
Glob bool
Dest string
Exclude []string
SymlinkStrategy string
}
func parse_copy_args(args []string) (*copy_options, []string, error) {
root := cli.Command{Name: `copy` }
root.Add(cli.OptionSpec{
            Name: "--glob",
            Type: "bool-set",
            Dest: "Glob",
            Help: "Interpret file arguments as glob patterns. Globbing is based on standard wildcards with the addition that ``/**/`` matches any number of directories. See the :link:`detailed syntax <https://github.com/bmatcuk/doublestar#patterns>`.",
        })
root.Add(cli.OptionSpec{
            Name: "--dest",
            Type: "",
            Dest: "Dest",
            Help: "The destination on the remote host to copy to. Relative paths are resolved relative to HOME on the remote host. When this option is not specified, the local file path is used as the remote destination (with the HOME directory getting automatically replaced by the remote HOME). Note that environment variables and ~ are not expanded.",
        })
root.Add(cli.OptionSpec{
            Name: "--exclude",
            Type: "list",
            Dest: "Exclude",
            Help: "A glob pattern. Files with names matching this pattern are excluded from being transferred. Only used when copying directories. Can be specified multiple times, if any of the patterns match the file will be excluded. If the pattern includes a :code:`/` then it will match against the full path, not just the filename. In such patterns you can use :code:`/**/` to match zero or more directories. For example, to exclude a directory and everything under it use :code:`**/directory_name`. See the :link:`detailed syntax <https://github.com/bmatcuk/doublestar#patterns>` for how wildcards match.",
        })
root.Add(cli.OptionSpec{
            Name: "--symlink-strategy",
            Type: "choices",
            Dest: "SymlinkStrategy",
            Help: "Control what happens if the specified path is a symlink. The default is to preserve the symlink, re-creating it on the remote machine. Setting this to :code:`resolve` will cause the symlink to be followed and its target used as the file/directory to copy. The value of :code:`keep-path` is the same as :code:`resolve` except that the remote file path is derived from the symlink's path instead of the path of the symlink's target. Note that this option does not apply to symlinks encountered while recursively copying directories, those are always preserved.",
        
Choices: "preserve, keep-path, resolve",

Completer: cli.NamesCompleter("Choices for symlink-strategy", "preserve", "keep-path", "resolve"),
	Default: "preserve",
})
cmd, err := root.ParseArgs(args)
if err != nil { return nil, nil, err }
var opts copy_options
err = cmd.GetOptionValues(&opts)
if err != nil { return nil, nil, err }
return &opts, cmd.Args, nil
}
