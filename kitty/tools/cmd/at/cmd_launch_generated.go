// Code generated by go_code.py; DO NOT EDIT.




// License: GPLv3 Copyright: 2022, Kovid Goyal, <kovid at kovidgoyal.net>

// Code generated by gen-go-code.py; DO NOT EDIT.

package at

import (
	"fmt"
	"strings"
	"time"

	"github.com/kovidgoyal/kitty/tools/cli"
	"github.com/kovidgoyal/kitty/tools/utils"
)

var _ = fmt.Print
var _ = strings.Join

type options_launch_type struct {
	Match string
WaitForChildToExit bool
Self bool
SourceWindow string
WindowTitle string
TabTitle string
Type string
KeepFocus bool
Cwd string
AddToSession string
Env []string
Var []string
Hold bool
CopyColors bool
CopyCmdline bool
CopyEnv bool
Location string
NextTo string
Bias float64
AllowRemoteControl bool
RemoteControlPassword []string
StdinSource string
StdinAddFormatting bool
StdinAddLineWrapMarkers bool
Marker string
OsWindowClass string
OsWindowName string
OsWindowTitle string
OsWindowState string
Logo string
LogoPosition string
LogoAlpha float64
Color []string
Spacing []string
Watcher []string
OsPanel []string
HoldAfterSsh bool
}

var options_launch options_launch_type

type launch_json_type struct {
	Args []escaped_string`json:"args,omitempty"`
Match escaped_string`json:"match,omitempty"`
Next_to escaped_string`json:"next_to,omitempty"`
Source_window escaped_string`json:"source_window,omitempty"`
Window_title escaped_string`json:"window_title,omitempty"`
Cwd escaped_string`json:"cwd,omitempty"`
Add_to_session escaped_string`json:"add_to_session,omitempty"`
Env []escaped_string`json:"env,omitempty"`
Var []escaped_string`json:"var,omitempty"`
Os_panel []escaped_string`json:"os_panel,omitempty"`
Tab_title escaped_string`json:"tab_title,omitempty"`
Type string`json:"type,omitempty"`
Keep_focus bool`json:"keep_focus,omitempty"`
Copy_colors bool`json:"copy_colors,omitempty"`
Copy_cmdline bool`json:"copy_cmdline,omitempty"`
Copy_env []escaped_string`json:"copy_env,omitempty"`
Hold bool`json:"hold,omitempty"`
Location string`json:"location,omitempty"`
Allow_remote_control bool`json:"allow_remote_control,omitempty"`
Remote_control_password []escaped_string`json:"remote_control_password,omitempty"`
Stdin_source string`json:"stdin_source,omitempty"`
Stdin_add_formatting bool`json:"stdin_add_formatting,omitempty"`
Stdin_add_line_wrap_markers bool`json:"stdin_add_line_wrap_markers,omitempty"`
Spacing []escaped_string`json:"spacing,omitempty"`
Marker escaped_string`json:"marker,omitempty"`
Logo escaped_string`json:"logo,omitempty"`
Logo_position escaped_string`json:"logo_position,omitempty"`
Logo_alpha float64`json:"logo_alpha"`
Self bool`json:"self,omitempty"`
Os_window_title escaped_string`json:"os_window_title,omitempty"`
Os_window_name escaped_string`json:"os_window_name,omitempty"`
Os_window_class escaped_string`json:"os_window_class,omitempty"`
Os_window_state string`json:"os_window_state,omitempty"`
Color []escaped_string`json:"color,omitempty"`
Watcher []escaped_string`json:"watcher,omitempty"`
Bias float64`json:"bias,omitempty"`
Wait_for_child_to_exit bool`json:"wait_for_child_to_exit,omitempty"`
Hold_after_ssh bool`json:"hold_after_ssh,omitempty"`
}

func create_payload_launch(io_data *rc_io_data, cmd *cli.Command, args []string) (err error) {
	payload := launch_json_type{}
	payload.Args = escape_list_of_strings(args)
payload.Match = escaped_string(options_launch.Match)
payload.Next_to = escaped_string(options_launch.NextTo)
payload.Source_window = escaped_string(options_launch.SourceWindow)
payload.Window_title = escaped_string(options_launch.WindowTitle)
payload.Cwd = escaped_string(options_launch.Cwd)
payload.Add_to_session = escaped_string(options_launch.AddToSession)
payload.Env = escape_list_of_strings(options_launch.Env)
payload.Var = escape_list_of_strings(options_launch.Var)
payload.Os_panel = escape_list_of_strings(options_launch.OsPanel)
payload.Tab_title = escaped_string(options_launch.TabTitle)
payload.Type = options_launch.Type
payload.Keep_focus = options_launch.KeepFocus
payload.Copy_colors = options_launch.CopyColors
payload.Copy_cmdline = options_launch.CopyCmdline
payload.Copy_env = escape_list_of_strings(copy_local_env(options_launch.CopyEnv))
payload.Hold = options_launch.Hold
payload.Location = options_launch.Location
payload.Allow_remote_control = options_launch.AllowRemoteControl
payload.Remote_control_password = escape_list_of_strings(options_launch.RemoteControlPassword)
payload.Stdin_source = options_launch.StdinSource
payload.Stdin_add_formatting = options_launch.StdinAddFormatting
payload.Stdin_add_line_wrap_markers = options_launch.StdinAddLineWrapMarkers
payload.Spacing = escape_list_of_strings(options_launch.Spacing)
payload.Marker = escaped_string(options_launch.Marker)
payload.Logo = escaped_string(options_launch.Logo)
payload.Logo_position = escaped_string(options_launch.LogoPosition)
payload.Logo_alpha = options_launch.LogoAlpha
payload.Self = options_launch.Self
payload.Os_window_title = escaped_string(options_launch.OsWindowTitle)
payload.Os_window_name = escaped_string(options_launch.OsWindowName)
payload.Os_window_class = escaped_string(options_launch.OsWindowClass)
payload.Os_window_state = options_launch.OsWindowState
payload.Color = escape_list_of_strings(options_launch.Color)
payload.Watcher = escape_list_of_strings(options_launch.Watcher)
payload.Bias = options_launch.Bias
payload.Wait_for_child_to_exit = options_launch.WaitForChildToExit
payload.Hold_after_ssh = options_launch.HoldAfterSsh
	io_data.rc.Payload = payload
	return
}

func create_rc_launch(args []string) (*utils.RemoteControlCmd, error) {
	rc := utils.RemoteControlCmd{
		Cmd:        "launch",
		Version:    ProtocolVersion,
		NoResponse: false,
		Stream:     false,
	}
	if rc.Stream {
		stream_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.StreamId = stream_id
	}
	if true {
		async_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.Async = async_id
	}
	return &rc, nil
}

func run_launch(cmd *cli.Command, args []string) (return_code int, err error) {
	err = cmd.GetOptionValues(&options_launch)
	if err != nil {
		return
	}

	rc, err := create_rc_launch(args)
	if err != nil {
		return
	}
	nrv, err := cli.GetOptionValue[bool](cmd, "NoResponse")
	if err == nil {
		rc.NoResponse = nrv
	}
	var timeout float64 = 10.0
	rt, err := cli.GetOptionValue[float64](cmd, "ResponseTimeout")
	if err == nil {
		timeout = rt
	}
	io_data := rc_io_data{
		cmd:                    cmd,
		rc:                     rc,
		timeout:                time.Duration(timeout * float64(time.Second)),
		string_response_is_err: false,
	}
	err = create_payload_launch(&io_data, cmd, args)
	if err != nil {
		return
	}

	err = send_rc_command(&io_data)
	if ee, ok := err.(*exit_error); ok && !running_shell {
		return ee.exit_code, nil
	}
	return
}

func setup_launch(parent *cli.Command) *cli.Command {
	ans := parent.AddSubCommand(&cli.Command{
		Name:             "launch",
		Usage:            " [CMD ...]",
		ShortDescription: "Run an arbitrary process in a new window/tab",
		HelpText:         "Prints out the id of the newly opened window. Any command line arguments are assumed to be the command line used to run in the new window, if none are provided, the default shell is run. For example::\n\n    kitten @ launch --title=Email mutt",
		Run:              run_launch,
	})
	ans.ArgCompleter = cli.CompleteExecutableFirstArg
ans.Add(cli.OptionSpec{
            Name: "--match -m",
            Type: "",
            Dest: "Match",
            Help: "The tab to match. Match specifications are of the form: :italic:`field:query`. Where :italic:`field` can be one of: :code:`id`, :code:`index`, :code:`title`, :code:`window_id`, :code:`window_title`, :code:`pid`, :code:`cwd`, :code:`cmdline` :code:`env`, :code:`var`, :code:`state`, :code:`session` and :code:`recent`. :italic:`query` is the expression to match. Expressions can be either a number or a regular expression, and can be :ref:`combined using Boolean operators <search_syntax>`.\n\nThe special value :code:`all` matches all tabs.\n\nFor numeric fields: :code:`id`, :code:`index`, :code:`window_id`, :code:`pid` and :code:`recent`, the expression is interpreted as a number, not a regular expression. Negative values for :code:`id`/:code:`window_id` match from the highest id number down, in particular, -1 is the most recently created tab/window.\n\nWhen using :code:`title` or :code:`id`, first a matching tab is looked for, and if not found a matching window is looked for, and the tab for that window is used.\n\nYou can also use :code:`window_id` and :code:`window_title` to match the tab that contains the window with the specified id or title.\n\nThe :code:`index` number is used to match the nth tab in the currently active OS window. The :code:`recent` number matches recently active tabs in the currently active OS window, with zero being the currently active tab, one the previously active tab and so on.\n\nThe field :code:`session` matches tabs that were created in the specified session. Use the expression :code:`^$` to match windows that were not created in a session and :code:`.` to match the currently active session and :code:`~` to match either the currently active sesison or the last active session when no session is active.\n\nWhen using the :code:`env` field to match on environment variables, you can specify only the environment variable name or a name and value, for example, :code:`env:MY_ENV_VAR=2`. Tabs containing any window with the specified environment variables are matched. Similarly, :code:`var` matches tabs containing any window with the specified user variable.\n\nThe field :code:`state` matches on the state of the tab. Supported states are: :code:`active`, :code:`focused`, :code:`needs_attention`, :code:`parent_active` and :code:`parent_focused`. Active tabs are the tabs that are active in their parent OS window. There is only one focused tab and it is the tab to which keyboard events are delivered. If no tab is focused, the last focused tab is matched.\n\nNote that you can use the :ref:`kitten @ ls <at-ls>` command to get a list of tabs.",
        })
ans.Add(cli.OptionSpec{
            Name: "--wait-for-child-to-exit",
            Type: "bool-set",
            Dest: "WaitForChildToExit",
            Help: "Wait until the launched program exits and print out its exit code. The exit code is printed out instead of the window id. If the program exited nromally its exit code is printed, which is always greater than or equal to zero. If the program was killed by a signal, the symbolic name of the SIGNAL is printed, if available, otherwise the signal number with a leading minus sign is printed.",
        })
ans.Add(cli.OptionSpec{
            Name: "--response-timeout",
            Type: "float",
            Dest: "ResponseTimeout",
            Help: "The time in seconds to wait for the started process to exit, when using the :option:`--wait-for-child-to-exit` option. Defaults to one day.",
        
	Default: "86400",
})
ans.Add(cli.OptionSpec{
            Name: "--no-response",
            Type: "bool-set",
            Dest: "NoResponse",
            Help: "Do not print out the id of the newly created window.",
        })
ans.Add(cli.OptionSpec{
            Name: "--self",
            Type: "bool-set",
            Dest: "Self",
            Help: "If specified the tab containing the window this command is run in is used instead of the active tab",
        })
ans.Add(cli.OptionSpec{
            Name: "--source-window",
            Type: "",
            Dest: "SourceWindow",
            Help: "A match expression to select the window from which data such as title, colors, env vars, screen contents, etc. are copied. When not specified the currently active window is used. See :ref:`search_syntax` for the syntax used for specifying windows.",
        })
ans.Add(cli.OptionSpec{
            Name: "--title --window-title",
            Type: "",
            Dest: "WindowTitle",
            Help: "The title to set for the new window. By default, title is controlled by the child process. The special value :code:`current` will copy the title from the :option:`source window <launch --source-window>`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--tab-title",
            Type: "",
            Dest: "TabTitle",
            Help: "The title for the new tab if launching in a new tab. By default, the title of the active window in the tab is used as the tab title. The special value :code:`current` will copy the title from the tab containing the :option:`source window <launch --source-window>`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--type",
            Type: "choices",
            Dest: "Type",
            Help: "Where to launch the child process:\n\n:code:`window`\n    A new :term:`kitty window <window>` in the current tab\n\n:code:`tab`\n    A new :term:`tab` in the current OS window. Not available when the :doc:`launch <launch>` command is used in :ref:`startup sessions <sessions>`.\n\n:code:`os-window`\n    A new :term:`operating system window <os_window>`.  Not available when the :doc:`launch <launch>` command is used in :ref:`startup sessions <sessions>`.\n\n:code:`overlay`\n    An :term:`overlay window <overlay>` covering the current active kitty window\n\n:code:`overlay-main`\n    An :term:`overlay window <overlay>` covering the current active kitty window. Unlike a plain overlay window, this window is considered as a :italic:`main` window which means it is used as the active window for getting the current working directory, the input text for kittens, launch commands, etc. Useful if this overlay is intended to run for a long time as a primary window.\n\n:code:`background`\n    The process will be run in the :italic:`background`, without a kitty window. Note that if :option:`kitten @ launch --allow-remote-control` is specified the :envvar:`KITTY_LISTEN_ON` environment variable will be set to a dedicated socket pair file descriptor that the process can use for remote control.\n\n:code:`clipboard`, :code:`primary`\n    These two are meant to work with :option:`--stdin-source <launch --stdin-source>` to copy data to the :italic:`system clipboard` or :italic:`primary selection`.\n\n:code:`os-panel`\n    Similar to :code:`os-window`, except that it creates the new OS Window as a desktop panel. Only works on platforms that support this, such as Wayand compositors that support the layer shell protocol. Use the :option:`kitten @ launch --os-panel` option to configure the panel.\n\n#placeholder_for_formatting#",
        
Choices: "window, background, clipboard, os-panel, os-window, overlay, overlay-main, primary, tab",

Completer: cli.NamesCompleter("Choices for type", "window", "background", "clipboard", "os-panel", "os-window", "overlay", "overlay-main", "primary", "tab"),
	Default: "window",
})
ans.Add(cli.OptionSpec{
            Name: "--dont-take-focus --keep-focus",
            Type: "bool-set",
            Dest: "KeepFocus",
            Help: "Keep the focus on the currently active window instead of switching to the newly opened window.",
        })
ans.Add(cli.OptionSpec{
            Name: "--cwd",
            Type: "",
            Dest: "Cwd",
            Help: "The working directory for the newly launched child. Use the special value :code:`current` to use the working directory of the :option:`source window <launch --source-window>` The special value :code:`last_reported` uses the last working directory reported by the shell (needs :ref:`shell_integration` to work). The special value :code:`oldest` works like :code:`current` but uses the working directory of the oldest foreground process associated with the currently active window rather than the newest foreground process. Finally, the special value :code:`root` refers to the process that was originally started when the window was created.\n\nWhen opening in the same working directory as the current window causes the new window to connect to a remote host, you can use the :option:`--hold-after-ssh` flag to prevent the new window from closing when the connection is terminated.",
        Completer: cli.ChainCompleters(cli.NamesCompleter("Keywords", "current", "oldest", "last_reported", "root"), cli.DirectoryCompleter("Directories", cli.CWD)),})
ans.Add(cli.OptionSpec{
            Name: "--add-to-session",
            Type: "",
            Dest: "AddToSession",
            Help: "Add the newly created window/tab to the specified session. Use :code:`.` to add to the session of the :option:`source window <launch --source-window>`, if any. See :ref:`sessions` for what a session is and how to use one. By default, the window is added to the session of the :option:`source window <launch --source-window>` when :option:`kitten @ launch --cwd` is set to use the the working directory from that window, otherwise the newly created window does not belong to any session. To force adding to no session, use the value :code:`!`. Adding a newly created window to a session is purely temporary, it does not change the actual session file, for that you have to resave the session. Note that using this flag in a launch command within a session file has no effect as the window is always added to the session belonging to that file.",
        })
ans.Add(cli.OptionSpec{
            Name: "--env",
            Type: "list",
            Dest: "Env",
            Help: "Environment variables to set in the child process. Can be specified multiple times to set different environment variables. Syntax: :code:`name=value`. Using :code:`name=` will set to empty string and just :code:`name` will remove the environment variable.",
        })
ans.Add(cli.OptionSpec{
            Name: "--var",
            Type: "list",
            Dest: "Var",
            Help: "User variables to set in the created window. Can be specified multiple times to set different user variables. Syntax: :code:`name=value`. Using :code:`name=` will set to empty string.",
        })
ans.Add(cli.OptionSpec{
            Name: "--hold",
            Type: "bool-set",
            Dest: "Hold",
            Help: "Keep the window open even after the command being executed exits, at a shell prompt. The shell will be run after the launched command exits.",
        })
ans.Add(cli.OptionSpec{
            Name: "--copy-colors",
            Type: "bool-set",
            Dest: "CopyColors",
            Help: "Set the colors of the newly created window to be the same as the colors in the :option:`source window <launch --source-window>`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--copy-cmdline",
            Type: "bool-set",
            Dest: "CopyCmdline",
            Help: "Ignore any specified command line and instead use the command line from the :option:`source window <launch --source-window>`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--copy-env",
            Type: "bool-set",
            Dest: "CopyEnv",
            Help: "Copy the environment variables from the :option:`source window <launch --source-window>` into the newly launched child process. Note that this only copies the environment when the window was first created, as it is not possible to get updated environment variables from arbitrary processes. To copy that environment, use either the :ref:`clone-in-kitty <clone_shell>` feature or the kitty remote control feature with :option:`kitten @ launch --copy-env`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--location",
            Type: "choices",
            Dest: "Location",
            Help: "Where to place the newly created window when it is added to a tab which already has existing windows in it. :code:`after` and :code:`before` place the new window before or after the active window. :code:`neighbor` is a synonym for :code:`after`. Also applies to creating a new tab, where the value of :code:`after` will cause the new tab to be placed next to the current tab instead of at the end. The values of :code:`vsplit`, :code:`hsplit` and :code:`split` are only used by the :code:`splits` layout and control if the new window is placed in a vertical, horizontal or automatic split with the currently active window. The default is to place the window in a layout dependent manner, typically, after the currently active window. See :option:`--next-to <launch --next-to>` to use a window other than the currently active window.",
        
Choices: "default, after, before, first, hsplit, last, neighbor, split, vsplit",

Completer: cli.NamesCompleter("Choices for location", "default", "after", "before", "first", "hsplit", "last", "neighbor", "split", "vsplit"),
	Default: "default",
})
ans.Add(cli.OptionSpec{
            Name: "--next-to",
            Type: "",
            Dest: "NextTo",
            Help: "A match expression to select the window next to which the new window is created. See :ref:`search_syntax` for the syntax for specifying windows. If not specified defaults to the active window. When used via remote control and a target tab is specified this option is ignored unless the matched window is in the specified tab. When using :option:`--type <launch --type>` of :code:`tab`, the tab will be created in the OS Window containing the matched window.",
        })
ans.Add(cli.OptionSpec{
            Name: "--bias",
            Type: "float",
            Dest: "Bias",
            Help: "The bias used to alter the size of the window. It controls what fraction of available space the window takes. The exact meaning of bias depends on the current layout.\n\n* Splits layout: The bias is interpreted as a percentage between 0 and 100. When splitting a window into two, the new window will take up the specified fraction of the space allotted to the original window and the original window will take up the remainder of the space.\n\n* Vertical/horizontal layout: The bias is interpreted as adding/subtracting from the normal size of the window. It should be a number between -90 and 90. This number is the percentage of the OS Window size that should be added to the window size. So for example, if a window would normally have been size 50 in the layout inside an OS Window that is size 80 high and --bias -10 is used it will become *approximately* size 42 high. Note that sizes are approximations, you cannot use this method to create windows of fixed sizes.\n\n* Tall layout: If the window being created is the *first* window in a column, then the bias is interpreted as a percentage, as for the splits layout, splitting the OS Window width between columns. If the window is a second or subsequent window in a column the bias is interpreted as adding/subtracting from the window size as for the vertical layout above.\n\n* Fat layout: Same as tall layout except it goes by rows instead of columns.\n\n* Grid layout: The bias is interpreted the same way as for the Vertical and Horizontal layouts, as something to be added/subtracted to the normal size. However, the since in a grid layout there are rows *and* columns, the bias on the first window in a column operates on the columns. Any later windows in that column operate on the row. So, for example, if you bias the first window in a grid layout it will change the width of the first column, the second window, the width of the second column, the third window, the height of the second row and so on.\n\nThe bias option was introduced in kitty version 0.36.0.",
        
	Default: "0",
})
ans.Add(cli.OptionSpec{
            Name: "--allow-remote-control",
            Type: "bool-set",
            Dest: "AllowRemoteControl",
            Help: "Programs running in this window can control kitty (even if remote control is not enabled in :file:`kitty.conf`). Note that any program with the right level of permissions can still write to the pipes of any other program on the same computer and therefore can control kitty. It can, however, be useful to block programs running on other computers (for example, over SSH) or as other users. See :option:`--remote-control-password` for ways to restrict actions allowed by remote control.",
        })
ans.Add(cli.OptionSpec{
            Name: "--remote-control-password",
            Type: "list",
            Dest: "RemoteControlPassword",
            Help: "Restrict the actions remote control is allowed to take. This works like :opt:`remote_control_password`. You can specify a password and list of actions just as for :opt:`remote_control_password`. For example::\n\n    --remote-control-password '\"my passphrase\" get-* set-colors'\n\nThis password will be in effect for this window only. Note that any passwords you have defined for :opt:`remote_control_password` in :file:`kitty.conf` are also in effect. You can override them by using the same password here. You can also disable all :opt:`remote_control_password` global passwords for this window, by using::\n\n    --remote-control-password '!'\n\nThis option only takes effect if :option:`--allow-remote-control` is also specified. Can be specified multiple times to create multiple passwords. This option was added to kitty in version 0.26.0",
        })
ans.Add(cli.OptionSpec{
            Name: "--stdin-source",
            Type: "choices",
            Dest: "StdinSource",
            Help: "Pass the screen contents as :file:`STDIN` to the child process.\n\n:code:`@selection`\n    is the currently selected text in the :option:`source window <launch --source-window>`.\n\n:code:`@screen`\n    is the contents of the :option:`source window <launch --source-window>`.\n\n:code:`@screen_scrollback`\n    is the same as :code:`@screen`, but includes the scrollback buffer as well.\n\n:code:`@alternate`\n    is the secondary screen of the :option:`source window <launch --source-window>`. For example if you run a full screen terminal application, the secondary screen will be the screen you return to when quitting the application.\n\n:code:`@first_cmd_output_on_screen`\n    is the output from the first command run in the shell on screen.\n\n:code:`@last_cmd_output`\n    is the output from the last command run in the shell.\n\n:code:`@last_visited_cmd_output`\n    is the first output below the last scrolled position via :ac:`scroll_to_prompt`, this needs :ref:`shell integration <shell_integration>` to work.\n\n#placeholder_for_formatting#",
        
Choices: "none, @alternate, @alternate_scrollback, @first_cmd_output_on_screen, @last_cmd_output, @last_visited_cmd_output, @screen, @screen_scrollback, @selection",

Completer: cli.NamesCompleter("Choices for stdin-source", "none", "@alternate", "@alternate_scrollback", "@first_cmd_output_on_screen", "@last_cmd_output", "@last_visited_cmd_output", "@screen", "@screen_scrollback", "@selection"),
	Default: "none",
})
ans.Add(cli.OptionSpec{
            Name: "--stdin-add-formatting",
            Type: "bool-set",
            Dest: "StdinAddFormatting",
            Help: "When using :option:`--stdin-source <launch --stdin-source>` add formatting escape codes, without this only plain text will be sent.",
        })
ans.Add(cli.OptionSpec{
            Name: "--stdin-add-line-wrap-markers",
            Type: "bool-set",
            Dest: "StdinAddLineWrapMarkers",
            Help: "When using :option:`--stdin-source <launch --stdin-source>` add a carriage return at every line wrap location (where long lines are wrapped at screen edges). This is useful if you want to pipe to program that wants to duplicate the screen layout of the screen.",
        })
ans.Add(cli.OptionSpec{
            Name: "--marker",
            Type: "",
            Dest: "Marker",
            Help: "Create a marker that highlights text in the newly created window. The syntax is the same as for the :ac:`toggle_marker` action (see :doc:`/marks`).",
        })
ans.Add(cli.OptionSpec{
            Name: "--os-window-class",
            Type: "",
            Dest: "OsWindowClass",
            Help: "Set the :italic:`WM_CLASS` property on X11 and the application id property on Wayland for the newly created OS window when using :option:`--type=os-window <launch --type>`. Defaults to whatever is used by the parent kitty process, which in turn defaults to :code:`kitty`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--os-window-name",
            Type: "",
            Dest: "OsWindowName",
            Help: "Set the :italic:`WM_NAME` property on X11 for the newly created OS Window when using :option:`--type=os-window <launch --type>`. Defaults to :option:`--os-window-class <launch --os-window-class>`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--os-window-title",
            Type: "",
            Dest: "OsWindowTitle",
            Help: "Set the title for the newly created OS window. This title will override any titles set by programs running in kitty. The special value :code:`current` will copy the title from the OS Window containing the :option:`source window <launch --source-window>`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--os-window-state",
            Type: "choices",
            Dest: "OsWindowState",
            Help: "The initial state for the newly created OS Window.",
        
Choices: "normal, fullscreen, maximized, minimized",

Completer: cli.NamesCompleter("Choices for os-window-state", "normal", "fullscreen", "maximized", "minimized"),
	Default: "normal",
})
ans.Add(cli.OptionSpec{
            Name: "--logo",
            Type: "",
            Dest: "Logo",
            Help: "Path to a PNG image to use as the logo for the newly created window. See :opt:`window_logo_path`. Relative paths are resolved from the kitty configuration directory.",
        Completer: cli.FnmatchCompleter("PNG images", cli.CONFIG, "*.png"),})
ans.Add(cli.OptionSpec{
            Name: "--logo-position",
            Type: "",
            Dest: "LogoPosition",
            Help: "The position for the window logo. Only takes effect if :option:`--logo` is specified. See :opt:`window_logo_position`.",
        })
ans.Add(cli.OptionSpec{
            Name: "--logo-alpha",
            Type: "float",
            Dest: "LogoAlpha",
            Help: "The amount the window logo should be faded into the background. Only takes effect if :option:`--logo` is specified. See :opt:`window_logo_alpha`.",
        
	Default: "-1",
})
ans.Add(cli.OptionSpec{
            Name: "--color",
            Type: "list",
            Dest: "Color",
            Help: "Change colors in the newly launched window. You can either specify a path to a :file:`.conf` file with the same syntax as :file:`kitty.conf` to read the colors from, or specify them individually, for example::\n\n    --color background=white --color foreground=red",
        })
ans.Add(cli.OptionSpec{
            Name: "--spacing",
            Type: "list",
            Dest: "Spacing",
            Help: "Set the margin and padding for the newly created window. For example: :code:`margin=20` or :code:`padding-left=10` or :code:`margin-h=30`. The shorthand form sets all values, the :code:`*-h` and :code:`*-v` variants set horizontal and vertical values. Can be specified multiple times. Note that this is ignored for overlay windows as these use the settings from the base window.",
        })
ans.Add(cli.OptionSpec{
            Name: "--watcher -w",
            Type: "list",
            Dest: "Watcher",
            Help: "Path to a Python file. Appropriately named functions in this file will be called for various events, such as when the window is resized, focused or closed. See the section on watchers in the launch command documentation: :ref:`watchers`. Relative paths are resolved relative to the :ref:`kitty config directory <confloc>`. Global watchers for all windows can be specified with :opt:`watcher` in :file:`kitty.conf`.",
        Completer: cli.FnmatchCompleter("Python scripts", cli.CONFIG, "*.py"),})
ans.Add(cli.OptionSpec{
            Name: "--os-panel",
            Type: "list",
            Dest: "OsPanel",
            Help: "Options to control the creation of desktop panels. Takes the same settings as the :doc:`panel kitten </kittens/panel>`, except for :option:`--override <kitty +kitten panel --override>` and :option:`--config <kitty +kitten panel --config>`. Can be specified multiple times. For example, to create a desktop panel at the bottom of the screen two lines high::\n\n    launch --type os-panel --os-panel lines=2 --os-panel edge=bottom sh -c \"echo; echo; echo hello; sleep 5s\"",
        })
ans.Add(cli.OptionSpec{
            Name: "--hold-after-ssh",
            Type: "bool-set",
            Dest: "HoldAfterSsh",
            Help: "When using :option:`--cwd`:code:`=current` or similar from a window that is running the ssh kitten, the new window will run a local shell after disconnecting from the remote host, when this option is specified.",
        })
	return ans
}

func init() {
	register_at_cmd(setup_launch)
}
