// Code generated by go_code.py; DO NOT EDIT.




// License: GPLv3 Copyright: 2022, Kovid Goyal, <kovid at kovidgoyal.net>

// Code generated by gen-go-code.py; DO NOT EDIT.

package at

import (
	"fmt"
	"strings"
	"time"

	"github.com/kovidgoyal/kitty/tools/cli"
	"github.com/kovidgoyal/kitty/tools/utils"
)

var _ = fmt.Print
var _ = strings.Join

type options_new_window_type struct {
	Match string
Title string
Cwd string
KeepFocus bool
WindowType string
NewTab bool
TabTitle string
}

var options_new_window options_new_window_type

type new_window_json_type struct {
	Args []escaped_string`json:"args,omitempty"`
Match escaped_string`json:"match,omitempty"`
Title escaped_string`json:"title,omitempty"`
Cwd escaped_string`json:"cwd,omitempty"`
Keep_focus bool`json:"keep_focus,omitempty"`
Window_type string`json:"window_type,omitempty"`
New_tab bool`json:"new_tab,omitempty"`
Tab_title escaped_string`json:"tab_title,omitempty"`
}

func create_payload_new_window(io_data *rc_io_data, cmd *cli.Command, args []string) (err error) {
	payload := new_window_json_type{}
	payload.Args = escape_list_of_strings(args)
payload.Match = escaped_string(options_new_window.Match)
payload.Title = escaped_string(options_new_window.Title)
payload.Cwd = escaped_string(options_new_window.Cwd)
payload.Keep_focus = options_new_window.KeepFocus
payload.Window_type = options_new_window.WindowType
payload.New_tab = options_new_window.NewTab
payload.Tab_title = escaped_string(options_new_window.TabTitle)
	io_data.rc.Payload = payload
	return
}

func create_rc_new_window(args []string) (*utils.RemoteControlCmd, error) {
	rc := utils.RemoteControlCmd{
		Cmd:        "new-window",
		Version:    ProtocolVersion,
		NoResponse: false,
		Stream:     false,
	}
	if rc.Stream {
		stream_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.StreamId = stream_id
	}
	if false {
		async_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.Async = async_id
	}
	return &rc, nil
}

func run_new_window(cmd *cli.Command, args []string) (return_code int, err error) {
	err = cmd.GetOptionValues(&options_new_window)
	if err != nil {
		return
	}

	rc, err := create_rc_new_window(args)
	if err != nil {
		return
	}
	nrv, err := cli.GetOptionValue[bool](cmd, "NoResponse")
	if err == nil {
		rc.NoResponse = nrv
	}
	var timeout float64 = 10.0
	rt, err := cli.GetOptionValue[float64](cmd, "ResponseTimeout")
	if err == nil {
		timeout = rt
	}
	io_data := rc_io_data{
		cmd:                    cmd,
		rc:                     rc,
		timeout:                time.Duration(timeout * float64(time.Second)),
		string_response_is_err: false,
	}
	err = create_payload_new_window(&io_data, cmd, args)
	if err != nil {
		return
	}

	err = send_rc_command(&io_data)
	if ee, ok := err.(*exit_error); ok && !running_shell {
		return ee.exit_code, nil
	}
	return
}

func setup_new_window(parent *cli.Command) *cli.Command {
	ans := parent.AddSubCommand(&cli.Command{
		Name:             "new-window",
		Usage:            " [CMD ...]",
		ShortDescription: "Open new window",
		HelpText:         "DEPRECATED: Use the :ref:`launch <at-launch>` command instead.\n\nOpen a new window in the specified tab. If you use the :option:`kitten @ new-window --match` option the first matching tab is used. Otherwise the currently active tab is used. Prints out the id of the newly opened window (unless :option:`--no-response` is used). Any command line arguments are assumed to be the command line used to run in the new window, if none are provided, the default shell is run. For example::\n\n    kitten @ new-window --title Email mutt",
		Run:              run_new_window,
	})
	ans.Add(cli.OptionSpec{
            Name: "--match -m",
            Type: "",
            Dest: "Match",
            Help: "The tab to match. Match specifications are of the form: :italic:`field:query`. Where :italic:`field` can be one of: :code:`id`, :code:`index`, :code:`title`, :code:`window_id`, :code:`window_title`, :code:`pid`, :code:`cwd`, :code:`cmdline` :code:`env`, :code:`var`, :code:`state`, :code:`session` and :code:`recent`. :italic:`query` is the expression to match. Expressions can be either a number or a regular expression, and can be :ref:`combined using Boolean operators <search_syntax>`.\n\nThe special value :code:`all` matches all tabs.\n\nFor numeric fields: :code:`id`, :code:`index`, :code:`window_id`, :code:`pid` and :code:`recent`, the expression is interpreted as a number, not a regular expression. Negative values for :code:`id`/:code:`window_id` match from the highest id number down, in particular, -1 is the most recently created tab/window.\n\nWhen using :code:`title` or :code:`id`, first a matching tab is looked for, and if not found a matching window is looked for, and the tab for that window is used.\n\nYou can also use :code:`window_id` and :code:`window_title` to match the tab that contains the window with the specified id or title.\n\nThe :code:`index` number is used to match the nth tab in the currently active OS window. The :code:`recent` number matches recently active tabs in the currently active OS window, with zero being the currently active tab, one the previously active tab and so on.\n\nThe field :code:`session` matches tabs that were created in the specified session. Use the expression :code:`^$` to match windows that were not created in a session and :code:`.` to match the currently active session and :code:`~` to match either the currently active sesison or the last active session when no session is active.\n\nWhen using the :code:`env` field to match on environment variables, you can specify only the environment variable name or a name and value, for example, :code:`env:MY_ENV_VAR=2`. Tabs containing any window with the specified environment variables are matched. Similarly, :code:`var` matches tabs containing any window with the specified user variable.\n\nThe field :code:`state` matches on the state of the tab. Supported states are: :code:`active`, :code:`focused`, :code:`needs_attention`, :code:`parent_active` and :code:`parent_focused`. Active tabs are the tabs that are active in their parent OS window. There is only one focused tab and it is the tab to which keyboard events are delivered. If no tab is focused, the last focused tab is matched.\n\nNote that you can use the :ref:`kitten @ ls <at-ls>` command to get a list of tabs.",
        })
ans.Add(cli.OptionSpec{
            Name: "--title",
            Type: "",
            Dest: "Title",
            Help: "The title for the new window. By default it will use the title set by the program running in it.",
        })
ans.Add(cli.OptionSpec{
            Name: "--cwd",
            Type: "",
            Dest: "Cwd",
            Help: "The initial working directory for the new window. Defaults to whatever the working directory for the kitty process you are talking to is.",
        })
ans.Add(cli.OptionSpec{
            Name: "--dont-take-focus --keep-focus",
            Type: "bool-set",
            Dest: "KeepFocus",
            Help: "Keep the current window focused instead of switching to the newly opened window.",
        })
ans.Add(cli.OptionSpec{
            Name: "--window-type",
            Type: "choices",
            Dest: "WindowType",
            Help: "What kind of window to open. A kitty window or a top-level OS window.",
        
Choices: "kitty, os",

Completer: cli.NamesCompleter("Choices for window-type", "kitty", "os"),
	Default: "kitty",
})
ans.Add(cli.OptionSpec{
            Name: "--new-tab",
            Type: "bool-set",
            Dest: "NewTab",
            Help: "Open a new tab.",
        })
ans.Add(cli.OptionSpec{
            Name: "--tab-title",
            Type: "",
            Dest: "TabTitle",
            Help: "Set the title of the tab, when open a new tab.",
        })
ans.Add(cli.OptionSpec{
            Name: "--no-response",
            Type: "bool-set",
            Dest: "NoResponse",
            Help: "Don't wait for a response giving the id of the newly opened window. Note that using this option means that you will not be notified of failures and that the id of the new window will not be printed out.",
        
	Default: "false",
})
	return ans
}

func init() {
	register_at_cmd(setup_new_window)
}
