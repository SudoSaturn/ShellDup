// Code generated by go_code.py; DO NOT EDIT.




// License: GPLv3 Copyright: 2022, Kovid Goyal, <kovid at kovidgoyal.net>

// Code generated by gen-go-code.py; DO NOT EDIT.

package at

import (
	"fmt"
	"strings"
	"time"

	"github.com/kovidgoyal/kitty/tools/cli"
	"github.com/kovidgoyal/kitty/tools/utils"
)

var _ = fmt.Print
var _ = strings.Join

type options_set_background_opacity_type struct {
	All bool
Toggle bool
Match string
MatchTab string
}

var options_set_background_opacity options_set_background_opacity_type

type set_background_opacity_json_type struct {
	Opacity float64`json:"opacity,omitempty"`
Match_window escaped_string`json:"match_window,omitempty"`
Match_tab escaped_string`json:"match_tab,omitempty"`
All bool`json:"all,omitempty"`
Toggle bool`json:"toggle,omitempty"`
}

func create_payload_set_background_opacity(io_data *rc_io_data, cmd *cli.Command, args []string) (err error) {
	payload := set_background_opacity_json_type{}
	if len(args) != 1 { return fmt.Errorf("%s", "Must specify exactly 1 argument(s) for set_background_opacity") }
payload.Opacity, err = parse_opacity(args[0])
if err != nil { return err }
payload.Match_tab = escaped_string(options_set_background_opacity.MatchTab)
payload.All = options_set_background_opacity.All
payload.Toggle = options_set_background_opacity.Toggle
payload.Match_window = escaped_string(options_set_background_opacity.Match)
	io_data.rc.Payload = payload
	return
}

func create_rc_set_background_opacity(args []string) (*utils.RemoteControlCmd, error) {
	rc := utils.RemoteControlCmd{
		Cmd:        "set-background-opacity",
		Version:    ProtocolVersion,
		NoResponse: false,
		Stream:     false,
	}
	if rc.Stream {
		stream_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.StreamId = stream_id
	}
	if false {
		async_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.Async = async_id
	}
	return &rc, nil
}

func run_set_background_opacity(cmd *cli.Command, args []string) (return_code int, err error) {
	err = cmd.GetOptionValues(&options_set_background_opacity)
	if err != nil {
		return
	}

	rc, err := create_rc_set_background_opacity(args)
	if err != nil {
		return
	}
	nrv, err := cli.GetOptionValue[bool](cmd, "NoResponse")
	if err == nil {
		rc.NoResponse = nrv
	}
	var timeout float64 = 10.0
	rt, err := cli.GetOptionValue[float64](cmd, "ResponseTimeout")
	if err == nil {
		timeout = rt
	}
	io_data := rc_io_data{
		cmd:                    cmd,
		rc:                     rc,
		timeout:                time.Duration(timeout * float64(time.Second)),
		string_response_is_err: false,
	}
	err = create_payload_set_background_opacity(&io_data, cmd, args)
	if err != nil {
		return
	}

	err = send_rc_command(&io_data)
	if ee, ok := err.(*exit_error); ok && !running_shell {
		return ee.exit_code, nil
	}
	return
}

func setup_set_background_opacity(parent *cli.Command) *cli.Command {
	ans := parent.AddSubCommand(&cli.Command{
		Name:             "set-background-opacity",
		Usage:            " OPACITY",
		ShortDescription: "Set the background opacity",
		HelpText:         "Set the background opacity for the specified windows. This will only work if you have turned on :opt:`dynamic_background_opacity` in :file:`kitty.conf`. The background opacity affects all kitty windows in a single OS window. For example::\n\n    kitten @ set-background-opacity 0.5",
		Run:              run_set_background_opacity,
	})
	ans.StopCompletingAtArg = 1
ans.Add(cli.OptionSpec{
            Name: "--all -a",
            Type: "bool-set",
            Dest: "All",
            Help: "By default, background opacity are only changed for the currently active OS window. This option will cause background opacity to be changed in all windows.",
        })
ans.Add(cli.OptionSpec{
            Name: "--toggle",
            Type: "bool-set",
            Dest: "Toggle",
            Help: "When specified, the background opacity for the matching OS windows will be reset to default if it is currently equal to the specified value, otherwise it will be set to the specified value.",
        })
ans.Add(cli.OptionSpec{
            Name: "--match -m",
            Type: "",
            Dest: "Match",
            Help: "The window to match. Match specifications are of the form: :italic:`field:query`. Where :italic:`field` can be one of: :code:`id`, :code:`title`, :code:`pid`, :code:`cwd`, :code:`cmdline`, :code:`num`, :code:`env`, :code:`var`, :code:`state`, :code:`neighbor`, :code:`session` and :code:`recent`. :italic:`query` is the expression to match. Expressions can be either a number or a regular expression, and can be :ref:`combined using Boolean operators <search_syntax>`.\n\nThe special value :code:`all` matches all windows.\n\nFor numeric fields: :code:`id`, :code:`pid`, :code:`num` and :code:`recent`, the expression is interpreted as a number, not a regular expression. Negative values for :code:`id` match from the highest id number down, in particular, -1 is the most recently created window.\n\nThe field :code:`num` refers to the window position in the current tab, starting from zero and counting clockwise (this is the same as the order in which the windows are reported by the :ref:`kitten @ ls <at-ls>` command).\n\nThe window id of the current window is available as the :envvar:`KITTY_WINDOW_ID` environment variable.\n\nThe field :code:`recent` refers to recently active windows in the currently active tab, with zero being the currently active window, one being the previously active window and so on.\n\nThe field :code:`neighbor` refers to a neighbor of the active window in the specified direction, which can be: :code:`left`, :code:`right`, :code:`top` or :code:`bottom`.\n\nThe field :code:`session` matches windows that were created in the specified session. Use the expression :code:`^$` to match windows that were not created in a session and :code:`.` to match the currently active session and :code:`~` to match either the currently active sesison or the last active session when no session is active.\n\nWhen using the :code:`env` field to match on environment variables, you can specify only the environment variable name or a name and value, for example, :code:`env:MY_ENV_VAR=2`.\n\nSimilarly, the :code:`var` field matches on user variables set on the window. You can specify name or name and value as with the :code:`env` field.\n\nThe field :code:`state` matches on the state of the window. Supported states are: :code:`active`, :code:`focused`, :code:`needs_attention`, :code:`parent_active`, :code:`parent_focused`, :code:`self`, :code:`overlay_parent`.  Active windows are the windows that are active in their parent tab. There is only one focused window and it is the window to which keyboard events are delivered. If no window is focused, the last focused window is matched. The value :code:`self` matches the window in which the remote control command is run. The value :code:`overlay_parent` matches the window that is under the :code:`self` window, when the self window is an overlay.\n\nNote that you can use the :ref:`kitten @ ls <at-ls>` command to get a list of windows.",
        })
ans.Add(cli.OptionSpec{
            Name: "--match-tab -t",
            Type: "",
            Dest: "MatchTab",
            Help: "The tab to match. Match specifications are of the form: :italic:`field:query`. Where :italic:`field` can be one of: :code:`id`, :code:`index`, :code:`title`, :code:`window_id`, :code:`window_title`, :code:`pid`, :code:`cwd`, :code:`cmdline` :code:`env`, :code:`var`, :code:`state`, :code:`session` and :code:`recent`. :italic:`query` is the expression to match. Expressions can be either a number or a regular expression, and can be :ref:`combined using Boolean operators <search_syntax>`.\n\nThe special value :code:`all` matches all tabs.\n\nFor numeric fields: :code:`id`, :code:`index`, :code:`window_id`, :code:`pid` and :code:`recent`, the expression is interpreted as a number, not a regular expression. Negative values for :code:`id`/:code:`window_id` match from the highest id number down, in particular, -1 is the most recently created tab/window.\n\nWhen using :code:`title` or :code:`id`, first a matching tab is looked for, and if not found a matching window is looked for, and the tab for that window is used.\n\nYou can also use :code:`window_id` and :code:`window_title` to match the tab that contains the window with the specified id or title.\n\nThe :code:`index` number is used to match the nth tab in the currently active OS window. The :code:`recent` number matches recently active tabs in the currently active OS window, with zero being the currently active tab, one the previously active tab and so on.\n\nThe field :code:`session` matches tabs that were created in the specified session. Use the expression :code:`^$` to match windows that were not created in a session and :code:`.` to match the currently active session and :code:`~` to match either the currently active sesison or the last active session when no session is active.\n\nWhen using the :code:`env` field to match on environment variables, you can specify only the environment variable name or a name and value, for example, :code:`env:MY_ENV_VAR=2`. Tabs containing any window with the specified environment variables are matched. Similarly, :code:`var` matches tabs containing any window with the specified user variable.\n\nThe field :code:`state` matches on the state of the tab. Supported states are: :code:`active`, :code:`focused`, :code:`needs_attention`, :code:`parent_active` and :code:`parent_focused`. Active tabs are the tabs that are active in their parent OS window. There is only one focused tab and it is the tab to which keyboard events are delivered. If no tab is focused, the last focused tab is matched.\n\nNote that you can use the :ref:`kitten @ ls <at-ls>` command to get a list of tabs.",
        })
	return ans
}

func init() {
	register_at_cmd(setup_set_background_opacity)
}
