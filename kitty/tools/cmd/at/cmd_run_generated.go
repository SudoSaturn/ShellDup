// Code generated by go_code.py; DO NOT EDIT.




// License: GPLv3 Copyright: 2022, Kovid Goyal, <kovid at kovidgoyal.net>

// Code generated by gen-go-code.py; DO NOT EDIT.

package at

import (
	"fmt"
	"strings"
	"time"

	"github.com/kovidgoyal/kitty/tools/cli"
	"github.com/kovidgoyal/kitty/tools/utils"
)

var _ = fmt.Print
var _ = strings.Join

type options_run_type struct {
	Env []string
AllowRemoteControl bool
RemoteControlPassword []string
}

var options_run options_run_type

type run_json_type struct {
	Data escaped_string`json:"data,omitempty"`
Cmdline []escaped_string`json:"cmdline,omitempty"`
Env []escaped_string`json:"env,omitempty"`
Allow_remote_control bool`json:"allow_remote_control,omitempty"`
Remote_control_password []escaped_string`json:"remote_control_password,omitempty"`
}

func create_payload_run(io_data *rc_io_data, cmd *cli.Command, args []string) (err error) {
	payload := run_json_type{}
	if len(args) < 1 { return fmt.Errorf("%s", "Must specify at least one argument to run") }
io_data.multiple_payload_generator, err = read_run_data(io_data, args, &payload)
if err != nil { return err }
payload.Env = escape_list_of_strings(options_run.Env)
payload.Allow_remote_control = options_run.AllowRemoteControl
payload.Remote_control_password = escape_list_of_strings(options_run.RemoteControlPassword)
	io_data.rc.Payload = payload
	return
}

func create_rc_run(args []string) (*utils.RemoteControlCmd, error) {
	rc := utils.RemoteControlCmd{
		Cmd:        "run",
		Version:    ProtocolVersion,
		NoResponse: false,
		Stream:     true,
	}
	if rc.Stream {
		stream_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.StreamId = stream_id
	}
	if true {
		async_id, err := utils.HumanRandomId(128)
		if err != nil {
			return nil, err
		}
		rc.Async = async_id
	}
	return &rc, nil
}

func run_run(cmd *cli.Command, args []string) (return_code int, err error) {
	err = cmd.GetOptionValues(&options_run)
	if err != nil {
		return
	}

	rc, err := create_rc_run(args)
	if err != nil {
		return
	}
	nrv, err := cli.GetOptionValue[bool](cmd, "NoResponse")
	if err == nil {
		rc.NoResponse = nrv
	}
	var timeout float64 = 10.0
	rt, err := cli.GetOptionValue[float64](cmd, "ResponseTimeout")
	if err == nil {
		timeout = rt
	}
	io_data := rc_io_data{
		cmd:                    cmd,
		rc:                     rc,
		timeout:                time.Duration(timeout * float64(time.Second)),
		string_response_is_err: false,
	}
	err = create_payload_run(&io_data, cmd, args)
	if err != nil {
		return
	}

	err = send_rc_command(&io_data)
	if ee, ok := err.(*exit_error); ok && !running_shell {
		return ee.exit_code, nil
	}
	return
}

func setup_run(parent *cli.Command) *cli.Command {
	ans := parent.AddSubCommand(&cli.Command{
		Name:             "run",
		Usage:            " CMD ...",
		ShortDescription: "Run a program on the computer in which kitty is running and get the output",
		HelpText:         "Run the specified program on the computer in which kitty is running. When STDIN is not a TTY it is forwarded to the program as its STDIN. STDOUT and STDERR from the the program are forwarded here. The exit status of this invocation will be the exit status of the executed program. If you wish to just run a program without waiting for a response,  use @ launch --type=background instead.",
		Run:              run_run,
	})
	ans.ArgCompleter = cli.CompleteExecutableFirstArg
ans.Add(cli.OptionSpec{
            Name: "--env",
            Type: "list",
            Dest: "Env",
            Help: "Environment variables to set in the child process. Can be specified multiple times to set different environment variables. Syntax: :code:`name=value`. Using :code:`name=` will set to empty string and just :code:`name` will remove the environment variable.",
        })
ans.Add(cli.OptionSpec{
            Name: "--allow-remote-control",
            Type: "bool-set",
            Dest: "AllowRemoteControl",
            Help: "The executed program will have privileges to run remote control commands in kitty.",
        })
ans.Add(cli.OptionSpec{
            Name: "--remote-control-password",
            Type: "list",
            Dest: "RemoteControlPassword",
            Help: "Restrict the actions remote control is allowed to take. This works like :opt:`remote_control_password`. You can specify a password and list of actions just as for :opt:`remote_control_password`. For example::\n\n    --remote-control-password '\"my passphrase\" get-* set-colors'\n\nThis password will be in effect for this window only. Note that any passwords you have defined for :opt:`remote_control_password` in :file:`kitty.conf` are also in effect. You can override them by using the same password here. You can also disable all :opt:`remote_control_password` global passwords for this window, by using::\n\n    --remote-control-password '!'\n\nThis option only takes effect if :option:`--allow-remote-control` is also specified. Can be specified multiple times to create multiple passwords. This option was added to kitty in version 0.26.0",
        })
	return ans
}

func init() {
	register_at_cmd(setup_run)
}
