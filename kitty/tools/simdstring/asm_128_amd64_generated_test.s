// Generated by generate.go do not edit
// vim: ft=goasm
//go:build amd64

#include "go_asm.h"
#include "textflag.h"

// func test_load_asm_128(src []byte, ans []byte)
TEXT ·test_load_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-48
	MOVQ src+0(FP), AX // load the function parameter src into AX 
	MOVOU (AX), X0 // load memory from the address in AX to X0 
	MOVQ ans+24(FP), AX // load the function parameter ans into AX 
	MOVOU X0, (AX) // store the value of X0 in to the memory whose address is in: AX 
	RET // return from function 


// func test_set1_epi8_asm_128(b uint8, ans []byte)
TEXT ·test_set1_epi8_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	MOVBQZX b+0(FP), AX // load the function parameter b into AX 
	MOVL $0x20, BX // BX =  32 
	CMPQ AX, BX // compare AX to BX 
	JE space // jump to: space if AX == BX 
	MOVL $0xb, BX // BX =  11 
	CMPQ AX, BX // compare AX to BX 
	JE eleven // jump to: eleven if AX == BX 
	// Set all bytes of X0 to the first byte in b 
	MOVBQZX b+0(FP), DX // load the function parameter b into DX 
	MOVL DX, X0
	PXOR X1, X1 // set X1 to zero 
	PSHUFB X1, X0
	// 
	MOVQ ans+8(FP), DX // load the function parameter ans into DX 
	MOVOU X0, (DX) // store the value of X0 in to the memory whose address is in: DX 
	RET // return from function 

space: // jump target 
	MOVL $0x20, DX // DX =  32 
	// Set all bytes of X0 to the lowest byte in DX 
	MOVL DX, X0
	PXOR X1, X1 // set X1 to zero 
	PSHUFB X1, X0
	// 
	MOVQ ans+8(FP), DX // load the function parameter ans into DX 
	MOVOU X0, (DX) // store the value of X0 in to the memory whose address is in: DX 
	RET // return from function 

eleven: // jump target 
	PCMPEQB X0, X0 // X0 = 0xff on every byte where X0[n] == X0[n] and zero elsewhere 
	MOVQ ans+8(FP), DX // load the function parameter ans into DX 
	MOVOU X0, (DX) // store the value of X0 in to the memory whose address is in: DX 
	RET // return from function 


// func test_cmpeq_epi8_asm_128(a []byte, b []byte, ans []byte)
TEXT ·test_cmpeq_epi8_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-72
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	MOVOU (AX), X0 // load memory from the address in AX to X0 
	MOVQ b+24(FP), AX // load the function parameter b into AX 
	MOVOU (AX), X1 // load memory from the address in AX to X1 
	PCMPEQB X1, X0 // X0 = 0xff on every byte where X0[n] == X1[n] and zero elsewhere 
	MOVQ ans+48(FP), AX // load the function parameter ans into AX 
	MOVOU X0, (AX) // store the value of X0 in to the memory whose address is in: AX 
	RET // return from function 


// func test_cmplt_epi8_asm_128(a []byte, b []byte, which int, ans []byte)
TEXT ·test_cmplt_epi8_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-80
	MOVQ which+48(FP), AX // load the function parameter which into AX 
	MOVQ a+0(FP), BX // load the function parameter a into BX 
	MOVOU (BX), X0 // load memory from the address in BX to X0 
	MOVQ b+24(FP), BX // load the function parameter b into BX 
	MOVOU (BX), X1 // load memory from the address in BX to X1 
	MOVL $0x1, BX // BX =  1 
	CMPQ AX, BX // compare AX to BX 
	JE one // jump to: one if AX == BX 
	MOVL $0x2, BX // BX =  2 
	CMPQ AX, BX // compare AX to BX 
	JE two // jump to: two if AX == BX 
	MOVOA X1, X2 // X2 = X1 
	PCMPGTB X0, X2 // X2 = 0xff on every byte where X1[n] > X0[n] and zero elsewhere 
	MOVQ ans+56(FP), DX // load the function parameter ans into DX 
	MOVOU X2, (DX) // store the value of X2 in to the memory whose address is in: DX 
	RET // return from function 

one: // jump target 
	MOVOA X1, X3 // X3 = X1 
	PCMPGTB X0, X3
	MOVOA X3, X0 // X0 = X3  // X0 = 0xff on every byte where X1[n] > X0[n] and zero elsewhere 
	MOVQ ans+56(FP), DX // load the function parameter ans into DX 
	MOVOU X0, (DX) // store the value of X0 in to the memory whose address is in: DX 
	RET // return from function 

two: // jump target 
	PCMPGTB X0, X1 // X1 = 0xff on every byte where X1[n] > X0[n] and zero elsewhere 
	MOVQ ans+56(FP), DX // load the function parameter ans into DX 
	MOVOU X1, (DX) // store the value of X1 in to the memory whose address is in: DX 
	RET // return from function 


// func test_or_asm_128(a []byte, b []byte, ans []byte)
TEXT ·test_or_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-72
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	MOVOU (AX), X0 // load memory from the address in AX to X0 
	MOVQ b+24(FP), AX // load the function parameter b into AX 
	MOVOU (AX), X1 // load memory from the address in AX to X1 
	POR X1, X0 // X0 = X0 | X1 (bitwise) 
	MOVQ ans+48(FP), AX // load the function parameter ans into AX 
	MOVOU X0, (AX) // store the value of X0 in to the memory whose address is in: AX 
	RET // return from function 


// func test_jump_if_zero_asm_128(a []byte) (ans int)
TEXT ·test_jump_if_zero_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	MOVOU (AX), X0 // load memory from the address in AX to X0 
	PTEST X0, X0 // test if X0 is zero 
	JZ zero // jump to: zero if X0 is zero 
	MOVQ $0x1, ans+24(FP) // save the value: 1 to the function return parameter: ans 
	RET // return from function 

zero: // jump target 
	MOVQ $0x0, ans+24(FP) // save the value: 0 to the function return parameter: ans 
	RET // return from function 


// func test_count_to_match_asm_128(a []byte, b uint8) (ans int)
TEXT ·test_count_to_match_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-40
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	MOVOU (AX), X0 // load memory from the address in AX to X0 
	// Set all bytes of X1 to the first byte in b 
	MOVBQZX b+24(FP), AX // load the function parameter b into AX 
	MOVL AX, X1
	PXOR X2, X2 // set X2 to zero 
	PSHUFB X2, X1
	// 
	PCMPEQB X0, X1 // X1 = 0xff on every byte where X0[n] == X1[n] and zero elsewhere 
	PTEST X1, X1 // test if X1 is zero 
	JZ fail // jump to: fail if X1 is zero 
	// Count the number of bytes to the first 0xff byte and put the result in AX 
	// Count the number of bytes to the first 0xff byte and put the result in AX 
	PMOVMSKB X1, AX // AX = mask of the highest bit in every byte in X1 
	BSFL AX, AX // AX = number of trailing zeros in AX 

	MOVQ AX, ans+32(FP) // save the value: AX to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+32(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


