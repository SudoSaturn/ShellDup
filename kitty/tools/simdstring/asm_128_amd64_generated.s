// Generated by generate.go do not edit
// vim: ft=goasm
//go:build amd64

#include "go_asm.h"
#include "textflag.h"

// func index_byte2_asm_128(data []byte, b1 uint8, b2 uint8) (ans int)
TEXT 路index_byte2_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-40
	// Set all bytes of X0 to the first byte in b1 
	MOVBQZX b1+24(FP), AX // load the function parameter b1 into AX 
	MOVL AX, X0
	PXOR X2, X2 // set X2 to zero 
	PSHUFB X2, X0
	// 
	// Set all bytes of X1 to the first byte in b2 
	MOVBQZX b2+25(FP), AX // load the function parameter b2 into AX 
	MOVL AX, X1
	PXOR X2, X2 // set X2 to zero 
	PSHUFB X2, X1
	// 
	MOVQ data+0(FP), BX // load the function parameter data into BX 
	MOVQ data_len+8(FP), DX // load the length of the function parameter data into DX 
	TESTQ DX, DX // test if DX is zero 
	JZ fail // jump to: fail if DX is zero 
	ADDQ BX, DX // DX += BX 
	MOVQ BX, AX // AX = BX 
	MOVQ BX, CX // CX = BX 
	ANDQ $0xf, CX // CX &= 15 
	SUBQ CX, AX // AX -= CX 
	// AX is now aligned to a 16 byte boundary so loading from it is safe 
	MOVOA (AX), X3 // load memory from the address in AX to X3 
	MOVOA X3, X2 // X2 = X3 
	PCMPEQB X0, X2 // X2 = 0xff on every byte where X3[n] == X0[n] and zero elsewhere 
	PCMPEQB X1, X3 // X3 = 0xff on every byte where X3[n] == X1[n] and zero elsewhere 
	POR X3, X2 // X2 = X2 | X3 (bitwise) 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X2, SI // SI = mask of the highest bit in every byte in X2 
	// We need to shift out the possible extra bytes at the start of the string caused by the unaligned read 
	SHRQ CX, SI
	TESTQ SI, SI // test if SI is zero 
	JZ loop_start // jump to: loop_start if SI is zero 
	MOVQ BX, AX // AX = BX 
	JMP byte_found_in_mask // jump to: byte_found_in_mask 
	// Now loop over aligned blocks 
loop_start: // jump target 
	ADDQ $0x10, AX // AX += 16 
	CMPQ DX, AX // compare DX to AX 
	JLE fail // jump to: fail if DX <= AX 
	MOVOA (AX), X3 // load memory from the address in AX to X3 
	MOVOA X3, X2 // X2 = X3 
	PCMPEQB X0, X2 // X2 = 0xff on every byte where X3[n] == X0[n] and zero elsewhere 
	PCMPEQB X1, X3 // X3 = 0xff on every byte where X3[n] == X1[n] and zero elsewhere 
	POR X3, X2 // X2 = X2 | X3 (bitwise) 
	PTEST X2, X2 // test if X2 is zero 
	JNZ byte_found_in_vec // jump to: byte_found_in_vec if X2 is non-zero 
	JMP loop_start // jump to: loop_start 
byte_found_in_vec: // jump target 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X2, SI // SI = mask of the highest bit in every byte in X2 
	// Get the result from SI and return it 
byte_found_in_mask: // jump target 
	BSFL SI, SI // SI = number of trailing zeros in SI 
	ADDQ AX, SI // SI += AX 
	CMPQ DX, SI // compare DX to SI 
	JLE fail // jump to: fail if DX <= SI 
	SUBQ BX, SI // SI -= BX 
	MOVQ SI, ans+32(FP) // save the value: SI to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+32(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


// func index_byte2_string_asm_128(data string, b1 uint8, b2 uint8) (ans int)
TEXT 路index_byte2_string_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	// Set all bytes of X0 to the first byte in b1 
	MOVBQZX b1+16(FP), AX // load the function parameter b1 into AX 
	MOVL AX, X0
	PXOR X2, X2 // set X2 to zero 
	PSHUFB X2, X0
	// 
	// Set all bytes of X1 to the first byte in b2 
	MOVBQZX b2+17(FP), AX // load the function parameter b2 into AX 
	MOVL AX, X1
	PXOR X2, X2 // set X2 to zero 
	PSHUFB X2, X1
	// 
	MOVQ data+0(FP), BX // load the function parameter data into BX 
	MOVQ data_len+8(FP), DX // load the length of the function parameter data into DX 
	TESTQ DX, DX // test if DX is zero 
	JZ fail // jump to: fail if DX is zero 
	ADDQ BX, DX // DX += BX 
	MOVQ BX, AX // AX = BX 
	MOVQ BX, CX // CX = BX 
	ANDQ $0xf, CX // CX &= 15 
	SUBQ CX, AX // AX -= CX 
	// AX is now aligned to a 16 byte boundary so loading from it is safe 
	MOVOA (AX), X3 // load memory from the address in AX to X3 
	MOVOA X3, X2 // X2 = X3 
	PCMPEQB X0, X2 // X2 = 0xff on every byte where X3[n] == X0[n] and zero elsewhere 
	PCMPEQB X1, X3 // X3 = 0xff on every byte where X3[n] == X1[n] and zero elsewhere 
	POR X3, X2 // X2 = X2 | X3 (bitwise) 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X2, SI // SI = mask of the highest bit in every byte in X2 
	// We need to shift out the possible extra bytes at the start of the string caused by the unaligned read 
	SHRQ CX, SI
	TESTQ SI, SI // test if SI is zero 
	JZ loop_start // jump to: loop_start if SI is zero 
	MOVQ BX, AX // AX = BX 
	JMP byte_found_in_mask // jump to: byte_found_in_mask 
	// Now loop over aligned blocks 
loop_start: // jump target 
	ADDQ $0x10, AX // AX += 16 
	CMPQ DX, AX // compare DX to AX 
	JLE fail // jump to: fail if DX <= AX 
	MOVOA (AX), X3 // load memory from the address in AX to X3 
	MOVOA X3, X2 // X2 = X3 
	PCMPEQB X0, X2 // X2 = 0xff on every byte where X3[n] == X0[n] and zero elsewhere 
	PCMPEQB X1, X3 // X3 = 0xff on every byte where X3[n] == X1[n] and zero elsewhere 
	POR X3, X2 // X2 = X2 | X3 (bitwise) 
	PTEST X2, X2 // test if X2 is zero 
	JNZ byte_found_in_vec // jump to: byte_found_in_vec if X2 is non-zero 
	JMP loop_start // jump to: loop_start 
byte_found_in_vec: // jump target 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X2, SI // SI = mask of the highest bit in every byte in X2 
	// Get the result from SI and return it 
byte_found_in_mask: // jump target 
	BSFL SI, SI // SI = number of trailing zeros in SI 
	ADDQ AX, SI // SI += AX 
	CMPQ DX, SI // compare DX to SI 
	JLE fail // jump to: fail if DX <= SI 
	SUBQ BX, SI // SI -= BX 
	MOVQ SI, ans+24(FP) // save the value: SI to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+24(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


// func index_c0_asm_128(data []byte) (ans int)
TEXT 路index_c0_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	PCMPEQB X0, X0 // X0 = 0xff on every byte where X0[n] == X0[n] and zero elsewhere 
	MOVL $0x20, AX // AX =  32 
	// Set all bytes of X1 to the lowest byte in AX 
	MOVL AX, X1
	PXOR X3, X3 // set X3 to zero 
	PSHUFB X3, X1
	// 
	MOVL $0x7f, AX // AX =  127 
	// Set all bytes of X2 to the lowest byte in AX 
	MOVL AX, X2
	PXOR X3, X3 // set X3 to zero 
	PSHUFB X3, X2
	// 
	MOVQ data+0(FP), BX // load the function parameter data into BX 
	MOVQ data_len+8(FP), DX // load the length of the function parameter data into DX 
	TESTQ DX, DX // test if DX is zero 
	JZ fail // jump to: fail if DX is zero 
	ADDQ BX, DX // DX += BX 
	MOVQ BX, AX // AX = BX 
	MOVQ BX, CX // CX = BX 
	ANDQ $0xf, CX // CX &= 15 
	SUBQ CX, AX // AX -= CX 
	// AX is now aligned to a 16 byte boundary so loading from it is safe 
	MOVOA (AX), X4 // load memory from the address in AX to X4 
	MOVOA X4, X3 // X3 = X4 
	PCMPEQB X2, X3 // X3 = 0xff on every byte where X4[n] == X2[n] and zero elsewhere 
	MOVOA X1, X5 // X5 = X1 
	PCMPGTB X4, X5 // X5 = 0xff on every byte where X1[n] > X4[n] and zero elsewhere 
	PCMPGTB X0, X4 // X4 = 0xff on every byte where X4[n] > X0[n] and zero elsewhere 
	PAND X5, X4 // X4 = X5 & X4 (bitwise) 
	POR X4, X3 // X3 = X3 | X4 (bitwise) 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X3, SI // SI = mask of the highest bit in every byte in X3 
	// We need to shift out the possible extra bytes at the start of the string caused by the unaligned read 
	SHRQ CX, SI
	TESTQ SI, SI // test if SI is zero 
	JZ loop_start // jump to: loop_start if SI is zero 
	MOVQ BX, AX // AX = BX 
	JMP byte_found_in_mask // jump to: byte_found_in_mask 
	// Now loop over aligned blocks 
loop_start: // jump target 
	ADDQ $0x10, AX // AX += 16 
	CMPQ DX, AX // compare DX to AX 
	JLE fail // jump to: fail if DX <= AX 
	MOVOA (AX), X4 // load memory from the address in AX to X4 
	MOVOA X4, X3 // X3 = X4 
	PCMPEQB X2, X3 // X3 = 0xff on every byte where X4[n] == X2[n] and zero elsewhere 
	MOVOA X1, X5 // X5 = X1 
	PCMPGTB X4, X5 // X5 = 0xff on every byte where X1[n] > X4[n] and zero elsewhere 
	PCMPGTB X0, X4 // X4 = 0xff on every byte where X4[n] > X0[n] and zero elsewhere 
	PAND X5, X4 // X4 = X5 & X4 (bitwise) 
	POR X4, X3 // X3 = X3 | X4 (bitwise) 
	PTEST X3, X3 // test if X3 is zero 
	JNZ byte_found_in_vec // jump to: byte_found_in_vec if X3 is non-zero 
	JMP loop_start // jump to: loop_start 
byte_found_in_vec: // jump target 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X3, SI // SI = mask of the highest bit in every byte in X3 
	// Get the result from SI and return it 
byte_found_in_mask: // jump target 
	BSFL SI, SI // SI = number of trailing zeros in SI 
	ADDQ AX, SI // SI += AX 
	CMPQ DX, SI // compare DX to SI 
	JLE fail // jump to: fail if DX <= SI 
	SUBQ BX, SI // SI -= BX 
	MOVQ SI, ans+24(FP) // save the value: SI to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+24(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


// func index_c0_string_asm_128(data string) (ans int)
TEXT 路index_c0_string_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-24
	PCMPEQB X0, X0 // X0 = 0xff on every byte where X0[n] == X0[n] and zero elsewhere 
	MOVL $0x20, AX // AX =  32 
	// Set all bytes of X1 to the lowest byte in AX 
	MOVL AX, X1
	PXOR X3, X3 // set X3 to zero 
	PSHUFB X3, X1
	// 
	MOVL $0x7f, AX // AX =  127 
	// Set all bytes of X2 to the lowest byte in AX 
	MOVL AX, X2
	PXOR X3, X3 // set X3 to zero 
	PSHUFB X3, X2
	// 
	MOVQ data+0(FP), BX // load the function parameter data into BX 
	MOVQ data_len+8(FP), DX // load the length of the function parameter data into DX 
	TESTQ DX, DX // test if DX is zero 
	JZ fail // jump to: fail if DX is zero 
	ADDQ BX, DX // DX += BX 
	MOVQ BX, AX // AX = BX 
	MOVQ BX, CX // CX = BX 
	ANDQ $0xf, CX // CX &= 15 
	SUBQ CX, AX // AX -= CX 
	// AX is now aligned to a 16 byte boundary so loading from it is safe 
	MOVOA (AX), X4 // load memory from the address in AX to X4 
	MOVOA X4, X3 // X3 = X4 
	PCMPEQB X2, X3 // X3 = 0xff on every byte where X4[n] == X2[n] and zero elsewhere 
	MOVOA X1, X5 // X5 = X1 
	PCMPGTB X4, X5 // X5 = 0xff on every byte where X1[n] > X4[n] and zero elsewhere 
	PCMPGTB X0, X4 // X4 = 0xff on every byte where X4[n] > X0[n] and zero elsewhere 
	PAND X5, X4 // X4 = X5 & X4 (bitwise) 
	POR X4, X3 // X3 = X3 | X4 (bitwise) 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X3, SI // SI = mask of the highest bit in every byte in X3 
	// We need to shift out the possible extra bytes at the start of the string caused by the unaligned read 
	SHRQ CX, SI
	TESTQ SI, SI // test if SI is zero 
	JZ loop_start // jump to: loop_start if SI is zero 
	MOVQ BX, AX // AX = BX 
	JMP byte_found_in_mask // jump to: byte_found_in_mask 
	// Now loop over aligned blocks 
loop_start: // jump target 
	ADDQ $0x10, AX // AX += 16 
	CMPQ DX, AX // compare DX to AX 
	JLE fail // jump to: fail if DX <= AX 
	MOVOA (AX), X4 // load memory from the address in AX to X4 
	MOVOA X4, X3 // X3 = X4 
	PCMPEQB X2, X3 // X3 = 0xff on every byte where X4[n] == X2[n] and zero elsewhere 
	MOVOA X1, X5 // X5 = X1 
	PCMPGTB X4, X5 // X5 = 0xff on every byte where X1[n] > X4[n] and zero elsewhere 
	PCMPGTB X0, X4 // X4 = 0xff on every byte where X4[n] > X0[n] and zero elsewhere 
	PAND X5, X4 // X4 = X5 & X4 (bitwise) 
	POR X4, X3 // X3 = X3 | X4 (bitwise) 
	PTEST X3, X3 // test if X3 is zero 
	JNZ byte_found_in_vec // jump to: byte_found_in_vec if X3 is non-zero 
	JMP loop_start // jump to: loop_start 
byte_found_in_vec: // jump target 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X3, SI // SI = mask of the highest bit in every byte in X3 
	// Get the result from SI and return it 
byte_found_in_mask: // jump target 
	BSFL SI, SI // SI = number of trailing zeros in SI 
	ADDQ AX, SI // SI += AX 
	CMPQ DX, SI // compare DX to SI 
	JLE fail // jump to: fail if DX <= SI 
	SUBQ BX, SI // SI -= BX 
	MOVQ SI, ans+16(FP) // save the value: SI to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+16(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


// func index_byte_asm_128(data []byte, b uint8) (ans int)
TEXT 路index_byte_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-40
	// Set all bytes of X0 to the first byte in b 
	MOVBQZX b+24(FP), AX // load the function parameter b into AX 
	MOVL AX, X0
	PXOR X1, X1 // set X1 to zero 
	PSHUFB X1, X0
	// 
	MOVQ data+0(FP), BX // load the function parameter data into BX 
	MOVQ data_len+8(FP), DX // load the length of the function parameter data into DX 
	TESTQ DX, DX // test if DX is zero 
	JZ fail // jump to: fail if DX is zero 
	ADDQ BX, DX // DX += BX 
	MOVQ BX, AX // AX = BX 
	MOVQ BX, CX // CX = BX 
	ANDQ $0xf, CX // CX &= 15 
	SUBQ CX, AX // AX -= CX 
	// AX is now aligned to a 16 byte boundary so loading from it is safe 
	MOVOA (AX), X2 // load memory from the address in AX to X2 
	MOVOA X2, X1 // X1 = X2 
	PCMPEQB X0, X1 // X1 = 0xff on every byte where X2[n] == X0[n] and zero elsewhere 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X1, SI // SI = mask of the highest bit in every byte in X1 
	// We need to shift out the possible extra bytes at the start of the string caused by the unaligned read 
	SHRQ CX, SI
	TESTQ SI, SI // test if SI is zero 
	JZ loop_start // jump to: loop_start if SI is zero 
	MOVQ BX, AX // AX = BX 
	JMP byte_found_in_mask // jump to: byte_found_in_mask 
	// Now loop over aligned blocks 
loop_start: // jump target 
	ADDQ $0x10, AX // AX += 16 
	CMPQ DX, AX // compare DX to AX 
	JLE fail // jump to: fail if DX <= AX 
	MOVOA (AX), X2 // load memory from the address in AX to X2 
	MOVOA X2, X1 // X1 = X2 
	PCMPEQB X0, X1 // X1 = 0xff on every byte where X2[n] == X0[n] and zero elsewhere 
	PTEST X1, X1 // test if X1 is zero 
	JNZ byte_found_in_vec // jump to: byte_found_in_vec if X1 is non-zero 
	JMP loop_start // jump to: loop_start 
byte_found_in_vec: // jump target 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X1, SI // SI = mask of the highest bit in every byte in X1 
	// Get the result from SI and return it 
byte_found_in_mask: // jump target 
	BSFL SI, SI // SI = number of trailing zeros in SI 
	ADDQ AX, SI // SI += AX 
	CMPQ DX, SI // compare DX to SI 
	JLE fail // jump to: fail if DX <= SI 
	SUBQ BX, SI // SI -= BX 
	MOVQ SI, ans+32(FP) // save the value: SI to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+32(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


// func index_byte_string_asm_128(data string, b uint8) (ans int)
TEXT 路index_byte_string_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	// Set all bytes of X0 to the first byte in b 
	MOVBQZX b+16(FP), AX // load the function parameter b into AX 
	MOVL AX, X0
	PXOR X1, X1 // set X1 to zero 
	PSHUFB X1, X0
	// 
	MOVQ data+0(FP), BX // load the function parameter data into BX 
	MOVQ data_len+8(FP), DX // load the length of the function parameter data into DX 
	TESTQ DX, DX // test if DX is zero 
	JZ fail // jump to: fail if DX is zero 
	ADDQ BX, DX // DX += BX 
	MOVQ BX, AX // AX = BX 
	MOVQ BX, CX // CX = BX 
	ANDQ $0xf, CX // CX &= 15 
	SUBQ CX, AX // AX -= CX 
	// AX is now aligned to a 16 byte boundary so loading from it is safe 
	MOVOA (AX), X2 // load memory from the address in AX to X2 
	MOVOA X2, X1 // X1 = X2 
	PCMPEQB X0, X1 // X1 = 0xff on every byte where X2[n] == X0[n] and zero elsewhere 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X1, SI // SI = mask of the highest bit in every byte in X1 
	// We need to shift out the possible extra bytes at the start of the string caused by the unaligned read 
	SHRQ CX, SI
	TESTQ SI, SI // test if SI is zero 
	JZ loop_start // jump to: loop_start if SI is zero 
	MOVQ BX, AX // AX = BX 
	JMP byte_found_in_mask // jump to: byte_found_in_mask 
	// Now loop over aligned blocks 
loop_start: // jump target 
	ADDQ $0x10, AX // AX += 16 
	CMPQ DX, AX // compare DX to AX 
	JLE fail // jump to: fail if DX <= AX 
	MOVOA (AX), X2 // load memory from the address in AX to X2 
	MOVOA X2, X1 // X1 = X2 
	PCMPEQB X0, X1 // X1 = 0xff on every byte where X2[n] == X0[n] and zero elsewhere 
	PTEST X1, X1 // test if X1 is zero 
	JNZ byte_found_in_vec // jump to: byte_found_in_vec if X1 is non-zero 
	JMP loop_start // jump to: loop_start 
byte_found_in_vec: // jump target 
	// Count the number of bytes to the first 0xff byte and put the result in SI 
	PMOVMSKB X1, SI // SI = mask of the highest bit in every byte in X1 
	// Get the result from SI and return it 
byte_found_in_mask: // jump target 
	BSFL SI, SI // SI = number of trailing zeros in SI 
	ADDQ AX, SI // SI += AX 
	CMPQ DX, SI // compare DX to SI 
	JLE fail // jump to: fail if DX <= SI 
	SUBQ BX, SI // SI -= BX 
	MOVQ SI, ans+24(FP) // save the value: SI to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+24(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


