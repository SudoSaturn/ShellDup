// Generated by generate.go do not edit
// vim: ft=goasm
//go:build arm64

#include "go_asm.h"
#include "textflag.h"

// func test_load_asm_128(src []byte, ans []byte)
TEXT ·test_load_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-48
	MOVD src+0(FP), R0 // load the function parameter src into R0 
	VLD1 (R0), [V0.B16] // load memory from the address in R0 to V0 
	MOVD ans+24(FP), R0 // load the function parameter ans into R0 
	VST1 [V0.B16], (R0) // store the value of V0 in to the memory whose address is in: R0 
	RET // return from function 


// func test_set1_epi8_asm_128(b uint8, ans []byte)
TEXT ·test_set1_epi8_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	MOVBU b+0(FP), R0 // load the function parameter b into R0 
	MOVD $0x20, R1 // R1 =  32 
	CMP R1, R0 // compare R0 to R1 
	BEQ space // jump to: space if R0 == R1 
	MOVD $0xb, R1 // R1 =  11 
	CMP R1, R0 // compare R0 to R1 
	BEQ eleven // jump to: eleven if R0 == R1 
	// Set all bytes of V0 to the first byte in b 
	MOVBU b+0(FP), R2 // load the function parameter b into R2 
	VMOV R2, V0.B16
	MOVD ans+8(FP), R2 // load the function parameter ans into R2 
	VST1 [V0.B16], (R2) // store the value of V0 in to the memory whose address is in: R2 
	RET // return from function 

space: // jump target 
	MOVD $0x20, R2 // R2 =  32 
	// Set all bytes of V0 to the lowest byte in R2 
	VMOV R2, V0.B16
	// 
	MOVD ans+8(FP), R2 // load the function parameter ans into R2 
	VST1 [V0.B16], (R2) // store the value of V0 in to the memory whose address is in: R2 
	RET // return from function 

eleven: // jump target 
	VCMEQ V0.B16, V0.B16, V0.B16 // V0 = 0xff on every byte where V0[n] == V0[n] and zero elsewhere 
	MOVD ans+8(FP), R2 // load the function parameter ans into R2 
	VST1 [V0.B16], (R2) // store the value of V0 in to the memory whose address is in: R2 
	RET // return from function 


// func test_cmpeq_epi8_asm_128(a []byte, b []byte, ans []byte)
TEXT ·test_cmpeq_epi8_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-72
	MOVD a+0(FP), R0 // load the function parameter a into R0 
	VLD1 (R0), [V0.B16] // load memory from the address in R0 to V0 
	MOVD b+24(FP), R0 // load the function parameter b into R0 
	VLD1 (R0), [V1.B16] // load memory from the address in R0 to V1 
	VCMEQ V0.B16, V1.B16, V0.B16 // V0 = 0xff on every byte where V0[n] == V1[n] and zero elsewhere 
	MOVD ans+48(FP), R0 // load the function parameter ans into R0 
	VST1 [V0.B16], (R0) // store the value of V0 in to the memory whose address is in: R0 
	RET // return from function 


// func test_cmplt_epi8_asm_128(a []byte, b []byte, which int, ans []byte)
TEXT ·test_cmplt_epi8_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-80
	MOVD which+48(FP), R0 // load the function parameter which into R0 
	MOVD a+0(FP), R1 // load the function parameter a into R1 
	VLD1 (R1), [V0.B16] // load memory from the address in R1 to V0 
	MOVD b+24(FP), R1 // load the function parameter b into R1 
	VLD1 (R1), [V1.B16] // load memory from the address in R1 to V1 
	MOVD $0x1, R1 // R1 =  1 
	CMP R1, R0 // compare R0 to R1 
	BEQ one // jump to: one if R0 == R1 
	MOVD $0x2, R1 // R1 =  2 
	CMP R1, R0 // compare R0 to R1 
	BEQ two // jump to: two if R0 == R1 
	WORD $0x4e203422 // V2 = 0xff on every byte where V1[n] > V0[n] and zero elsewhere 
	MOVD ans+56(FP), R2 // load the function parameter ans into R2 
	VST1 [V2.B16], (R2) // store the value of V2 in to the memory whose address is in: R2 
	RET // return from function 

one: // jump target 
	WORD $0x4e203420 // V0 = 0xff on every byte where V1[n] > V0[n] and zero elsewhere 
	MOVD ans+56(FP), R2 // load the function parameter ans into R2 
	VST1 [V0.B16], (R2) // store the value of V0 in to the memory whose address is in: R2 
	RET // return from function 

two: // jump target 
	WORD $0x4e203421 // V1 = 0xff on every byte where V1[n] > V0[n] and zero elsewhere 
	MOVD ans+56(FP), R2 // load the function parameter ans into R2 
	VST1 [V1.B16], (R2) // store the value of V1 in to the memory whose address is in: R2 
	RET // return from function 


// func test_or_asm_128(a []byte, b []byte, ans []byte)
TEXT ·test_or_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-72
	MOVD a+0(FP), R0 // load the function parameter a into R0 
	VLD1 (R0), [V0.B16] // load memory from the address in R0 to V0 
	MOVD b+24(FP), R0 // load the function parameter b into R0 
	VLD1 (R0), [V1.B16] // load memory from the address in R0 to V1 
	VORR V0.B16, V1.B16, V0.B16 // V0 = V0 | V1 (bitwise) 
	MOVD ans+48(FP), R0 // load the function parameter ans into R0 
	VST1 [V0.B16], (R0) // store the value of V0 in to the memory whose address is in: R0 
	RET // return from function 


// func test_jump_if_zero_asm_128(a []byte) (ans int)
TEXT ·test_jump_if_zero_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	MOVD a+0(FP), R0 // load the function parameter a into R0 
	VLD1 (R0), [V0.B16] // load memory from the address in R0 to V0 
	VDUP V0.D[1], V1 // duplicate the upper 64 bits of V0 into the lower and upper 64 bits of V1 
	VORR V0.B16, V1.B16, V1.B16 // V1 = V0 | V1 (bitwise) 
	FMOVD F1, R0 // R0 = lower 64bits of V1 
	CBZ R0, zero // jump to: zero if V0 is zero 
	MOVD $0x1, R0 // R0 =  1 
	MOVD R0, ans+24(FP) // save the value: 1 to the function return parameter: ans 
	RET // return from function 

zero: // jump target 
	MOVW $0x0, R0 // set R0 to zero 
	MOVD R0, ans+24(FP) // save the value: 0 to the function return parameter: ans 
	RET // return from function 


// func test_count_to_match_asm_128(a []byte, b uint8) (ans int)
TEXT ·test_count_to_match_asm_128(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-40
	MOVD a+0(FP), R0 // load the function parameter a into R0 
	VLD1 (R0), [V0.B16] // load memory from the address in R0 to V0 
	// Set all bytes of V1 to the first byte in b 
	MOVBU b+24(FP), R0 // load the function parameter b into R0 
	VMOV R0, V1.B16
	VCMEQ V0.B16, V1.B16, V1.B16 // V1 = 0xff on every byte where V0[n] == V1[n] and zero elsewhere 
	VDUP V1.D[1], V2 // duplicate the upper 64 bits of V1 into the lower and upper 64 bits of V2 
	VORR V1.B16, V2.B16, V2.B16 // V2 = V1 | V2 (bitwise) 
	FMOVD F2, R0 // R0 = lower 64bits of V2 
	CBZ R0, fail // jump to: fail if V1 is zero 
	// Count the number of bytes to the first 0xff byte and put the result in R0 
	// Count the number of bytes to the first 0xff byte and put the result in R0 
	// Go assembler doesn't support the shrn instruction, below we have: shrn.8b V1 V1 #4 
	// It is shifting right by four bits in every 16 bit word and truncating to 8 bits storing the result in the lower 64 bits of V1 
	WORD $0xf0c8421
	FMOVD F1, R0 // Extract the lower 64 bits from V1 and put them into R0 
	RBIT R0, R0 // reverse the bits 
	CLZ R0, R0 // R0 = number of leading zeros in R0 
	UBFX $2, R0, $30, R0 // R0 >>= 2 (divide by 4) 

	MOVD R0, ans+32(FP) // save the value: R0 to the function return parameter: ans 
	RET // return from function 

fail: // jump target 
	MOVD $-1, R1 // R1 = all ones 
	MOVD R1, ans+32(FP) // save the value: -1 to the function return parameter: ans 
	RET // return from function 


