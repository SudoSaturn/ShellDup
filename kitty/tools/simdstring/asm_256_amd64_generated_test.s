// Generated by generate.go do not edit
// vim: ft=goasm
//go:build amd64

#include "go_asm.h"
#include "textflag.h"

// func test_load_asm_256(src []byte, ans []byte)
TEXT ·test_load_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-48
	MOVQ src+0(FP), AX // load the function parameter src into AX 
	VMOVDQU (AX), Y0 // load memory from the address in AX to Y0 
	MOVQ ans+24(FP), AX // load the function parameter ans into AX 
	VMOVDQU Y0, (AX) // store the value of Y0 in to the memory whose address is in: AX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


// func test_set1_epi8_asm_256(b uint8, ans []byte)
TEXT ·test_set1_epi8_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	MOVBQZX b+0(FP), AX // load the function parameter b into AX 
	MOVL $0x20, BX // BX =  32 
	CMPQ AX, BX // compare AX to BX 
	JE space // jump to: space if AX == BX 
	MOVL $0xb, BX // BX =  11 
	CMPQ AX, BX // compare AX to BX 
	JE eleven // jump to: eleven if AX == BX 
	// Set all bytes of Y0 to the first byte in b 
	VPBROADCASTB b+0(FP), Y0
	// 
	MOVQ ans+8(FP), DX // load the function parameter ans into DX 
	VMOVDQU Y0, (DX) // store the value of Y0 in to the memory whose address is in: DX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 

space: // jump target 
	MOVL $0x20, DX // DX =  32 
	// Set all bytes of Y0 to the lowest byte in DX 
	VMOVD DX, X1
	VPBROADCASTB X1, Y0
	// 
	MOVQ ans+8(FP), DX // load the function parameter ans into DX 
	VMOVDQU Y0, (DX) // store the value of Y0 in to the memory whose address is in: DX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 

eleven: // jump target 
	VPCMPEQB Y0, Y0, Y0 // Y0 = 0xff on every byte where Y0[n] == Y0[n] and zero elsewhere 
	MOVQ ans+8(FP), DX // load the function parameter ans into DX 
	VMOVDQU Y0, (DX) // store the value of Y0 in to the memory whose address is in: DX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


// func test_cmpeq_epi8_asm_256(a []byte, b []byte, ans []byte)
TEXT ·test_cmpeq_epi8_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-72
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	VMOVDQU (AX), Y0 // load memory from the address in AX to Y0 
	MOVQ b+24(FP), AX // load the function parameter b into AX 
	VMOVDQU (AX), Y1 // load memory from the address in AX to Y1 
	VPCMPEQB Y1, Y0, Y0 // Y0 = 0xff on every byte where Y0[n] == Y1[n] and zero elsewhere 
	MOVQ ans+48(FP), AX // load the function parameter ans into AX 
	VMOVDQU Y0, (AX) // store the value of Y0 in to the memory whose address is in: AX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


// func test_cmplt_epi8_asm_256(a []byte, b []byte, which int, ans []byte)
TEXT ·test_cmplt_epi8_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-80
	MOVQ which+48(FP), AX // load the function parameter which into AX 
	MOVQ a+0(FP), BX // load the function parameter a into BX 
	VMOVDQU (BX), Y0 // load memory from the address in BX to Y0 
	MOVQ b+24(FP), BX // load the function parameter b into BX 
	VMOVDQU (BX), Y1 // load memory from the address in BX to Y1 
	MOVL $0x1, BX // BX =  1 
	CMPQ AX, BX // compare AX to BX 
	JE one // jump to: one if AX == BX 
	MOVL $0x2, BX // BX =  2 
	CMPQ AX, BX // compare AX to BX 
	JE two // jump to: two if AX == BX 
	VPCMPGTB Y0, Y1, Y2 // Y2 = 0xff on every byte where Y1[n] > Y0[n] and zero elsewhere 
	MOVQ ans+56(FP), DX // load the function parameter ans into DX 
	VMOVDQU Y2, (DX) // store the value of Y2 in to the memory whose address is in: DX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 

one: // jump target 
	VPCMPGTB Y0, Y1, Y0 // Y0 = 0xff on every byte where Y1[n] > Y0[n] and zero elsewhere 
	MOVQ ans+56(FP), DX // load the function parameter ans into DX 
	VMOVDQU Y0, (DX) // store the value of Y0 in to the memory whose address is in: DX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 

two: // jump target 
	VPCMPGTB Y0, Y1, Y1 // Y1 = 0xff on every byte where Y1[n] > Y0[n] and zero elsewhere 
	MOVQ ans+56(FP), DX // load the function parameter ans into DX 
	VMOVDQU Y1, (DX) // store the value of Y1 in to the memory whose address is in: DX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


// func test_or_asm_256(a []byte, b []byte, ans []byte)
TEXT ·test_or_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-72
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	VMOVDQU (AX), Y0 // load memory from the address in AX to Y0 
	MOVQ b+24(FP), AX // load the function parameter b into AX 
	VMOVDQU (AX), Y1 // load memory from the address in AX to Y1 
	VPOR Y0, Y1, Y0 // Y0 = Y0 | Y1 (bitwise) 
	MOVQ ans+48(FP), AX // load the function parameter ans into AX 
	VMOVDQU Y0, (AX) // store the value of Y0 in to the memory whose address is in: AX 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


// func test_jump_if_zero_asm_256(a []byte) (ans int)
TEXT ·test_jump_if_zero_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-32
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	VMOVDQU (AX), Y0 // load memory from the address in AX to Y0 
	VPTEST Y0, Y0 // test if Y0 is zero 
	JZ zero // jump to: zero if Y0 is zero 
	MOVQ $0x1, ans+24(FP) // save the value: 1 to the function return parameter: ans 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 

zero: // jump target 
	MOVQ $0x0, ans+24(FP) // save the value: 0 to the function return parameter: ans 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


// func test_count_to_match_asm_256(a []byte, b uint8) (ans int)
TEXT ·test_count_to_match_asm_256(SB), NOSPLIT|TOPFRAME|NOFRAME, $0-40
	MOVQ a+0(FP), AX // load the function parameter a into AX 
	VMOVDQU (AX), Y0 // load memory from the address in AX to Y0 
	// Set all bytes of Y1 to the first byte in b 
	VPBROADCASTB b+24(FP), Y1
	// 
	VPCMPEQB Y1, Y0, Y1 // Y1 = 0xff on every byte where Y0[n] == Y1[n] and zero elsewhere 
	VPTEST Y1, Y1 // test if Y1 is zero 
	JZ fail // jump to: fail if Y1 is zero 
	// Count the number of bytes to the first 0xff byte and put the result in AX 
	// Count the number of bytes to the first 0xff byte and put the result in AX 
	VPMOVMSKB Y1, AX // AX = mask of the highest bit in every byte in Y1 
	BSFL AX, AX // AX = number of trailing zeros in AX 

	MOVQ AX, ans+32(FP) // save the value: AX to the function return parameter: ans 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 

fail: // jump target 
	MOVQ $-1, ans+32(FP) // save the value: -1 to the function return parameter: ans 
	VZEROUPPER // zero upper bits of AVX registers to avoid dependencies when switching between SSE and AVX code 
	RET // return from function 


